<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aquarium</title>
    <link rel="icon" type="image/png" href="favicon.ico">
    
    <!-- Basic SEO Meta Tags -->
    <meta name="description" content="Interactive procedural aquarium simulation with luminous fish. Create your own underwater experience with bioluminescent creatures in this relaxing virtual environment.">
    <meta name="keywords" content="aquarium, procedural animation, bioluminescent fish, interactive simulation, virtual aquarium, luminous fish">
    <meta name="author" content="davidroman0O">

    <!-- Canonical URL -->
    <link rel="canonical" href="https://procedural-aquarium.vercel.app/">

    <!-- Open Graph Meta Tags for Social Sharing -->
    <meta property="og:title" content="Luminous Fish Simulation - Interactive Procedural Aquarium">
    <meta property="og:description" content="Relax with this stunning virtual aquarium featuring procedurally generated bioluminescent fish that respond to your interaction.">
    <meta property="og:image" content="https://procedural-aquarium.vercel.app/procedural-fishes-aquarium.png">
    <meta property="og:url" content="https://procedural-aquarium.vercel.app/">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Procedural Aquarium">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Luminous Fish Simulation - Interactive Procedural Aquarium">
    <meta name="twitter:description" content="Relax with this stunning virtual aquarium featuring procedurally generated bioluminescent fish that respond to your interaction.">
    <meta name="twitter:image" content="https://procedural-aquarium.vercel.app/procedural-fishes-aquarium.png">

    <!-- Twitter - but... i don't have one... maybe should I?! -->
    <!-- <meta name="twitter:creator" content="@idonthaveatwitteraccountbro"> -->

    <!-- Structured Data / JSON-LD -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Luminous Fish Simulation",
        "description": "Interactive procedural aquarium simulation with luminous fish. Create your own underwater experience with bioluminescent creatures.",
        "applicationCategory": "Simulation",
        "operatingSystem": "Any",
        "author": {
            "@type": "Person",
            "name": "davidroman0O",
            "url": "https://github.com/davidroman0O"
        },
        "screenshot": "https://procedural-aquarium.vercel.app/procedural-fishes-aquarium.png",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD",
            "availability": "https://schema.org/InStock"
        }
    }
    </script>

    <!-- Favicon (improved with different sizes) -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
        }
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 20, 0.7);
            color: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 400px;
            font-size: 14px;
            z-index: 100;
            transition: opacity 0.3s;
        }
        .info-panel:hover {
            opacity: 1;
        }
        .info-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #00ffff;
        }
        .info-panel h4 {
            color: #0080ff;
            margin-top: 12px;
            margin-bottom: 5px;
        }
        .info-panel p {
            margin: 5px 0;
        }
        .info-panel ul {
            padding-left: 20px;
            margin: 5px 0;
        }
        .info-panel li {
            margin-bottom: 4px;
        }
        .info-panel a {
            color: #0080ff;
            text-decoration: none;
            transition: color 0.2s;
        }
        .info-panel a:hover {
            color: #ff00ff;
            text-decoration: underline;
        }
        .github-corner {
            position: absolute;
            top: 0;
            right: 0;
            z-index: 100;
        }
        .github-corner svg {
            fill: #0080ff;
            color: #000;
            transition: fill 0.3s;
        }
        .github-corner:hover svg {
            fill: #ff00ff;
        }
        .minimize-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 16px;
        }
        .minimize-btn:hover {
            color: white;
        }
        .show-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 20, 0.7);
            color: rgba(255, 255, 255, 0.8);
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <a href="https://github.com/davidroman0O/aquarium-fish-procedural" class="github-corner" aria-label="View on GitHub">
        <svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true">
            <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
            <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
            <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
        </svg>
    </a>
    
     
    <div id="info-panel" class="info-panel">
        <button id="minimize-btn" class="minimize-btn">Ã—</button>
        <h3>Luminous Fish Simulation</h3>
        <p>A procedural animation of bioluminescent fish in a virtual aquarium.</p>
        
        <h4 id="controls-title">Controls:</h4>
        <div id="desktop-controls">
            <ul>
                <li><strong>Left-click:</strong> Add food particles that attract fish</li>
                <li><strong>Right-click:</strong> Add a new fish at cursor position</li>
                <li><strong>Mouse movement:</strong> Creates gentle water currents</li>
            </ul>
        </div>
        <div id="mobile-controls" style="display: none;">
            <ul>
                <li><strong>Tap:</strong> Add food particles that attract fish</li>
                <li><strong>Double-tap:</strong> Add a new fish at tap position</li>
                <li><strong>Touch and drag:</strong> Creates gentle water currents</li>
            </ul>
        </div>
        
        <h4>About the Flow:</h4>
        <p>The fish move using a dynamic flow system that simulates natural swimming behaviors:</p>
        <ul>
            <li>Each fish has a spine system that provides realistic movement</li>
            <li>Fish are attracted to food when hungry</li>
            <li>Water currents affect both fish and food particles</li>
            <li>Luminosity pulses to simulate bioluminescence</li>
            <li>Fish adapt their swimming patterns based on energy levels</li>
        </ul>
        
        <p><strong>GitHub:</strong> <a href="https://github.com/davidroman0O/aquarium-fish-procedural" target="_blank">davidroman0O/aquarium-fish-procedural</a></p>
    </div>
    

    <script src="workerController.js"></script>
    
    <script>
        // Mobile detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Set up the canvas
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Make canvas fill the window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            createBackground(); // Recreate background on resize
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Mouse state tracking
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let pmouseX = mouseX;
        let pmouseY = mouseY;
        let mouseInfluence = false;
        
        // Track mouse position
        canvas.addEventListener('mousemove', (e) => {
            pmouseX = mouseX;
            pmouseY = mouseY;
            mouseX = e.clientX;
            mouseY = e.clientY;
            mouseInfluence = true;
            
            // Reset mouse influence after a short delay
            clearTimeout(mouseInfluenceTimer);
            mouseInfluenceTimer = setTimeout(() => {
                mouseInfluence = false;
            }, 100);
        });
        
        let mouseInfluenceTimer;
        
        // Create a background with a subtle gradient
        function createBackground() {
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 1.5
            );
            
            gradient.addColorStop(0, '#060a0f');
            gradient.addColorStop(1, '#03050a');
            
            return gradient;
        }

        let background = createBackground();
        
        // Simplified water flow simulation - gentler values
        const waterFlow = {
            // Overall water flow direction and strength (reduced)
            baseVx: 0.01,
            baseVy: 0.005,
            // Current flow variation
            vx: 0,
            vy: 0,
            // Target flow variation (we'll smoothly interpolate to this)
            targetVx: 0,
            targetVy: 0,
            // Time until we pick a new target
            changeTimer: 200
        };

        // Food system
        const foods = [];
        
        function addFood(x, y) {
            const newFoods = [];
            for (let i = 0; i < 5; i++) {
                newFoods.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    size: 3 + Math.random() * 2,
                    energy: 10 + Math.random() * 5,
                    color: `hsl(${30 + Math.random() * 30}, 100%, 70%)`,
                    vx: (Math.random() - 0.5) * 0.3, // Reduced initial velocity
                    vy: (Math.random() - 0.5) * 0.3, // Reduced initial velocity
                    alpha: 1.0,
                    // Add scale properties for animation
                    scale: 0.01, // Start very small
                    targetScale: 1.0, // Target full size
                    scaleSpeed: 0.04 + Math.random() * 0.02, // Randomize speed slightly
                    // Each food has slight variation in how it responds to current
                    flowMultiplier: 0.7 + Math.random() * 0.6
                });
            }
            
            // Add to the worker controller
            workerController.addFoods(newFoods);
        }

        // Luminous fish class with improved movement
        class Fish {
            constructor() {
                // Position and movement
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.angle = Math.random() * Math.PI * 2;
                
                // Slower velocity on mobile
                this.velocity = isMobile ? 
                    0.3 + Math.random() * 0.7 : // Slower on mobile
                    0.5 + Math.random() * 1.5;  // Normal on desktop
                    
                this.turnSpeed = 0.02 + Math.random() * 0.03;
                
                // Visual properties
                this.length = 15 + Math.random() * 25;
                this.width = this.length * 0.3;
                this.tailLength = this.length * 0.8;
                this.tailWidth = this.width * 1.5;
                
                // Choose a color scheme
                this.chooseColor();
                
                // Swimming motion
                this.swimPhase = Math.random() * Math.PI * 2;
                this.swimSpeed = 0.05 + Math.random() * 0.05;
                this.swimAmplitude = 0.15 + Math.random() * 0.1;
                
                // Behavior
                this.wanderAngle = Math.random() * Math.PI * 2;
                this.wanderSpeed = 0.01 + Math.random() * 0.03;
                this.targetX = this.x;
                this.targetY = this.y;
                this.targetChangeTimer = 0;
                
                // Energy and hunger
                this.energy = 0.7 + Math.random() * 0.3;
                this.hungry = false;
                this.huntingTarget = null;
                this.timeToNextHunger = 500 + Math.random() * 1000;
                
                // Fish turning mechanics
                this.vx = 0;
                this.vy = 0;
                this.targetVx = 0;
                this.targetVy = 0;
                this.turnAcceleration = 0.02 + Math.random() * 0.02;
                this.turnDirection = 0; // -1 left, 0 straight, 1 right
                this.turnTimer = 0;
                this.commitMove = 0;
                this.commitMax = 5;
                this.directionCounter = 0;
                
                // Create spine points
                this.spinePoints = [];
                this.createSpine();
                
                // Luminosity and glow
                this.glow = 0.7 + Math.random() * 0.3;
                this.glowSize = 5 + Math.random() * 10;
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.pulseSpeed = 0.02 + Math.random() * 0.03;
                
                // Add properties for eating animation
                this.eatEffectTime = 0;
                this.maxEatEffectTime = 25; // How long the eating effect lasts
            }
            
            chooseColor() {
                // Vibrant color options
                const colors = [
                    { main: '#00ffff', glow: '#00ffff' }, // Cyan
                    { main: '#ff00ff', glow: '#ff00ff' }, // Magenta
                    { main: '#ffff00', glow: '#ffff00' }, // Yellow
                    { main: '#ff8000', glow: '#ff8000' }, // Orange
                    { main: '#00ff00', glow: '#00ff00' }, // Green
                    { main: '#ff0080', glow: '#ff0080' }, // Pink
                    { main: '#0080ff', glow: '#0080ff' }  // Light blue
                ];
                
                this.color = colors[Math.floor(Math.random() * colors.length)];
                
                // Add slight color variation
                this.color.main = this.shiftColorHue(this.color.main, Math.random() * 20 - 10);
                this.color.glow = this.color.main;
            }
            
            createSpine() {
                // Create spine points for smoother animation
                const segments = 10;
                
                for (let i = 0; i < segments; i++) {
                    this.spinePoints.push({
                        x: this.x,
                        y: this.y,
                        angle: this.angle
                    });
                }
            }
            
            update() {
                // Update swimming animation
                this.swimPhase += this.swimSpeed * this.energy;
                this.pulsePhase += this.pulseSpeed;
                
                // Update hunger
                this.timeToNextHunger--;
                if (this.timeToNextHunger <= 0) {
                    this.hungry = true;
                    this.energy = Math.max(0.3, this.energy - 0.1);
                    this.timeToNextHunger = 500 + Math.random() * 500;
                }
                
                // Check for food if hungry
                if (this.hungry) {
                    this.checkForFood();
                }
                
                // Decide on movement target
                this.targetChangeTimer--;
                if (this.targetChangeTimer <= 0) {
                    this.updateTarget();
                }
                
                // Calculate direction to target
                let targetAngle;
                
                if (mouseInfluence && Math.random() < 0.005) {
                    // Occasionally be attracted to mouse
                    const dx = mouseX - this.x;
                    const dy = mouseY - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 300) {
                        targetAngle = Math.atan2(dy, dx);
                        // Increase speed when following mouse (adjusted for mobile)
                        this.velocity = isMobile ? 
                            1 + Math.random() * 0.5 : // Slower on mobile 
                            2 + Math.random();        // Normal on desktop
                    } else {
                        targetAngle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                        // Return to normal speed (adjusted for mobile)
                        this.velocity = isMobile ? 
                            0.3 + Math.random() * 0.7 : // Slower on mobile
                            0.5 + Math.random() * 1.5;  // Normal on desktop
                    }
                } else {
                    targetAngle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                }
                
                // Improved turning mechanics
                let angleDiff = targetAngle - this.angle;
                
                // Normalize angle difference to range [-PI, PI]
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                
                // Apply turning with commitment behavior
                if (this.commitMove < 0) {
                    this.angle -= this.turnSpeed * 1.5;
                    this.commitMove += 1;
                    this.turnDirection = -1;
                } else if (this.commitMove > 0) {
                    this.angle += this.turnSpeed * 1.5;
                    this.commitMove -= 1;
                    this.turnDirection = 1;
                } else if (angleDiff > 0.1) {
                    this.angle += this.turnSpeed * this.energy;
                    this.turnDirection = 1;
                    
                    // Sometimes commit to a turn
                    if (this.directionCounter > 0) {
                        this.directionCounter++;
                        if (this.directionCounter > 2 * this.commitMax) {
                            this.commitMove = 1 + Math.floor(this.commitMax / 3);
                            this.directionCounter = 0;
                        }
                    } else {
                        this.directionCounter = 1;
                    }
                } else if (angleDiff < -0.1) {
                    this.angle -= this.turnSpeed * this.energy;
                    this.turnDirection = -1;
                    
                    // Sometimes commit to a turn
                    if (this.directionCounter < 0) {
                        this.directionCounter--;
                        if (this.directionCounter < -2 * this.commitMax) {
                            this.commitMove = -1 - Math.floor(this.commitMax / 3);
                            this.directionCounter = 0;
                        }
                    } else {
                        this.directionCounter = -1;
                    }
                } else {
                    // Close enough to target angle, apply small correction
                    this.angle += angleDiff * this.turnSpeed * 0.5;
                    this.turnDirection = 0;
                }
                
                // Calculate target velocity with proper acceleration
                this.targetVx = Math.cos(this.angle) * this.velocity * this.energy;
                this.targetVy = Math.sin(this.angle) * this.velocity * this.energy;
                
                // Smoothly apply acceleration
                this.vx += (this.targetVx - this.vx) * this.turnAcceleration;
                this.vy += (this.targetVy - this.vy) * this.turnAcceleration;
                
                // Move the fish
                this.x += this.vx;
                this.y += this.vy;
                
                // Screen wrapping
                if (this.x < -this.length) this.x = canvas.width + this.length;
                if (this.x > canvas.width + this.length) this.x = -this.length;
                if (this.y < -this.length) this.y = canvas.height + this.length;
                if (this.y > canvas.height + this.length) this.y = -this.length;
                
                // Update spine points with spring physics
                this.updateSpine();
                
                // Decrease eat effect timer if active
                if (this.eatEffectTime > 0) {
                    this.eatEffectTime--;
                }
            }
            
            checkForFood() {
                const foods = workerController.getFoods();
                for (let i = foods.length - 1; i >= 0; i--) {
                    const food = foods[i];
                    const dx = food.x - this.x;
                    const dy = food.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // If close enough to eat
                    if (dist < this.width) {
                        // Consume food and gain energy
                        this.energy = Math.min(1.0, this.energy + food.energy/100);
                        this.hungry = false;
                        this.targetChangeTimer = 0;
                        
                        // Trigger eating animation effect
                        this.eatEffectTime = this.maxEatEffectTime;
                        
                        // Create particle effect at food location
                        createEatingEffect(food.x, food.y, food.color);
                        
                        workerController.removeFood(i);
                        break;
                    } else if (dist < 200) {
                        // Chase nearby food
                        this.targetX = food.x;
                        this.targetY = food.y;
                        this.targetChangeTimer = 10;
                    }
                }
            }
            
            updateTarget() {
                // How long until we change target again
                this.targetChangeTimer = 100 + Math.random() * 200;
                
                // Check for food if hungry
                const foods = workerController.getFoods();
                if (this.hungry && foods.length > 0) {
                    let closest = Infinity;
                    let closestFood = null;
                    
                    for (const food of foods) {
                        const dx = food.x - this.x;
                        const dy = food.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < closest && dist < 300) {
                            closest = dist;
                            closestFood = food;
                        }
                    }
                    
                    if (closestFood) {
                        this.targetX = closestFood.x;
                        this.targetY = closestFood.y;
                        return;
                    }
                }
                
                // If not targeting food, choose a new wandering target
                // Choose a new target with smooth wandering
                this.wanderAngle += (Math.random() - 0.5) * 0.3;
                
                // Center of canvas plus wander offset
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const wanderRadius = Math.min(canvas.width, canvas.height) * 0.3;
                
                this.targetX = centerX + Math.cos(this.wanderAngle) * wanderRadius;
                this.targetY = centerY + Math.sin(this.wanderAngle) * wanderRadius;
                
                // Add some randomness
                this.targetX += (Math.random() - 0.5) * 200;
                this.targetY += (Math.random() - 0.5) * 200;
                
                // Keep within screen bounds
                const margin = 100;
                this.targetX = Math.max(margin, Math.min(canvas.width - margin, this.targetX));
                this.targetY = Math.max(margin, Math.min(canvas.height - margin, this.targetY));
            }
            
            updateSpine() {
                // Update first spine point to fish position
                this.spinePoints[0] = {
                    x: this.x,
                    y: this.y,
                    angle: this.angle
                };
                
                // Update remaining spine points with delay
                for (let i = 1; i < this.spinePoints.length; i++) {
                    const prev = this.spinePoints[i-1];
                    const curr = this.spinePoints[i];
                    
                    // Distance between spine points
                    const segmentLength = this.length / (this.spinePoints.length - 1);
                    
                    // Calculate target angle with swim wiggle (stronger when turning)
                    const turnFactor = Math.abs(this.turnDirection) * 1.5;
                    const swimWiggle = Math.sin(this.swimPhase - i * 0.3) * 
                                      this.swimAmplitude * 
                                      (i / this.spinePoints.length) * 
                                      (1 + turnFactor);
                    
                    const targetAngle = prev.angle + swimWiggle;
                    
                    // Smooth angle transition
                    curr.angle = curr.angle + (targetAngle - curr.angle) * 0.2;
                    
                    // Calculate new position based on angle and distance
                    curr.x = prev.x - Math.cos(curr.angle) * segmentLength;
                    curr.y = prev.y - Math.sin(curr.angle) * segmentLength;
                }
            }
            
            draw() {
                ctx.save();
                
                // Calculate additional glow boost when eating
                let eatBoost = 0;
                if (this.eatEffectTime > 0) {
                    // Create a pulse effect that rises quickly and fades
                    eatBoost = Math.sin((this.maxEatEffectTime - this.eatEffectTime) / this.maxEatEffectTime * Math.PI) * 1.5;
                }
                
                // Luminosity effect with pulsing
                const glowPulse = 0.7 + Math.sin(this.pulsePhase) * 0.3;
                ctx.shadowColor = this.color.glow;
                ctx.shadowBlur = (this.glowSize + eatBoost * 5) * glowPulse; // Larger glow when eating
                ctx.globalAlpha = (this.glow + eatBoost * 0.2) * glowPulse * Math.max(0.6, this.energy);
                
                // Luminous body
                this.drawBody(eatBoost);
                
                // Draw extra glow effect
                ctx.globalAlpha = (0.4 + eatBoost * 0.3) * glowPulse * Math.max(0.6, this.energy);
                ctx.shadowBlur = (this.glowSize + eatBoost * 8) * 1.5;
                this.drawBody(eatBoost);
                
                ctx.restore();
            }
            
            drawBody(eatBoost = 0) {
                // Scale boost for when fish eats (subtle size increase)
                const sizeBoost = 1 + eatBoost * 0.1;
                
                // Calculate points for fish body
                let points = [];
                
                // Draw fish based on spine points
                for (let i = 0; i < this.spinePoints.length; i++) {
                    const t = i / (this.spinePoints.length - 1); // Position along spine (0-1)
                    const spine = this.spinePoints[i];
                    
                    // Fish width varies along the length
                    let width;
                    if (t < 0.3) {
                        // Head to middle (thicken)
                        width = this.width * (0.5 + t * 1.5) * sizeBoost;
                    } else {
                        // Middle to tail (taper)
                        width = this.width * (1 - (t - 0.3) * 1.4) * sizeBoost;
                    }
                    
                    // Only add points for the main body (not the tail)
                    if (i < this.spinePoints.length - 2) {
                        points.push({
                            x: spine.x,
                            y: spine.y,
                            angle: spine.angle,
                            width: width
                        });
                    }
                }
                
                // Draw smooth fish body
                ctx.beginPath();
                
                // Start from the head
                ctx.moveTo(points[0].x, points[0].y);
                
                // Top curve
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    const x = p.x + Math.sin(p.angle) * p.width / 2;
                    const y = p.y - Math.cos(p.angle) * p.width / 2;
                    
                    if (i === 0) {
                        ctx.lineTo(x, y);
                    } else {
                        // Create smooth curve
                        const prev = points[i-1];
                        const prevX = prev.x + Math.sin(prev.angle) * prev.width / 2;
                        const prevY = prev.y - Math.cos(prev.angle) * prev.width / 2;
                        
                        const cpX = (prevX + x) / 2;
                        const cpY = (prevY + y) / 2;
                        
                        ctx.quadraticCurveTo(cpX, cpY, x, y);
                    }
                }
                
                // Add tail tip
                const lastPoint = this.spinePoints[this.spinePoints.length - 1];
                ctx.lineTo(lastPoint.x, lastPoint.y);
                
                // Bottom curve (in reverse)
                for (let i = points.length - 1; i >= 0; i--) {
                    const p = points[i];
                    const x = p.x - Math.sin(p.angle) * p.width / 2;
                    const y = p.y + Math.cos(p.angle) * p.width / 2;
                    
                    if (i === points.length - 1) {
                        ctx.lineTo(x, y);
                    } else {
                        // Create smooth curve
                        const next = points[i+1];
                        const nextX = next.x - Math.sin(next.angle) * next.width / 2;
                        const nextY = next.y + Math.cos(next.angle) * next.width / 2;
                        
                        const cpX = (nextX + x) / 2;
                        const cpY = (nextY + y) / 2;
                        
                        ctx.quadraticCurveTo(cpX, cpY, x, y);
                    }
                }
                
                ctx.closePath();
                
                // Create gradient
                const gradStart = {
                    x: this.spinePoints[0].x,
                    y: this.spinePoints[0].y
                };
                
                const gradEnd = {
                    x: this.spinePoints[this.spinePoints.length - 1].x,
                    y: this.spinePoints[this.spinePoints.length - 1].y
                };
                
                const gradient = ctx.createLinearGradient(gradStart.x, gradStart.y, gradEnd.x, gradEnd.y);
                gradient.addColorStop(0, this.color.main);
                gradient.addColorStop(0.4, this.lightenColor(this.color.main, 30));
                gradient.addColorStop(1, this.color.main);
                
                ctx.fillStyle = gradient;
                ctx.fill();
            }
            
            // Utility function to lighten/darken color
            lightenColor(color, percent) {
                const num = parseInt(color.slice(1), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.min(255, Math.max(0, (num >> 16) + amt));
                const G = Math.min(255, Math.max(0, (num >> 8 & 0x00FF) + amt));
                const B = Math.min(255, Math.max(0, (num & 0x0000FF) + amt));
                return `#${(0x1000000 + (R << 16) + (G << 8) + B).toString(16).slice(1)}`;
            }
            
            // Shift color hue
            shiftColorHue(color, degree) {
                // Convert hex to RGB
                let r = parseInt(color.substring(1, 3), 16);
                let g = parseInt(color.substring(3, 5), 16);
                let b = parseInt(color.substring(5, 7), 16);
                
                // Convert RGB to HSL
                r /= 255;
                g /= 255;
                b /= 255;
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                
                if (max === min) {
                    h = s = 0; // achromatic
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    
                    h /= 6;
                }
                
                // Shift hue
                h = (h + degree / 360) % 1;
                
                // Convert back to RGB
                let r1, g1, b1;
                
                if (s === 0) {
                    r1 = g1 = b1 = l; // achromatic
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    
                    r1 = hue2rgb(p, q, h + 1/3);
                    g1 = hue2rgb(p, q, h);
                    b1 = hue2rgb(p, q, h - 1/3);
                }
                
                // Convert to hex
                const toHex = x => {
                    const hex = Math.round(x * 255).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                };
                
                return `#${toHex(r1)}${toHex(g1)}${toHex(b1)}`;
            }
        }

        // Create fish
        const fishCount = 25;
        const fishes = [];

        for (let i = 0; i < fishCount; i++) {
            fishes.push(new Fish());
        }

        // FPS counter variables
        let lastFrameTime = 0;
        let frameCount = 0;
        let fps = 0;
        let fpsUpdateInterval = 500; // Update FPS display every 500ms
        let lastFpsUpdate = 0;

        // Create FPS display element
        const fpsCounter = document.createElement('div');
        fpsCounter.style.position = 'absolute';
        fpsCounter.style.top = '10px';
        fpsCounter.style.right = '10px';
        fpsCounter.style.backgroundColor = 'rgba(0, 0, 20, 0.7)';
        fpsCounter.style.color = '#00ffff';
        fpsCounter.style.padding = '5px 10px';
        fpsCounter.style.borderRadius = '4px';
        fpsCounter.style.fontFamily = 'monospace';
        fpsCounter.style.fontSize = '14px';
        fpsCounter.style.zIndex = '1000';
        document.body.appendChild(fpsCounter);
        
        // Initialize the worker controller
        const workerController = new WorkerController();
        
        // Set initial data
        workerController.setFishes(fishes);
        workerController.setWaterFlow(waterFlow);
        workerController.setFoods(foods);

        // Drawing functions - these remain on the main thread
        function drawFlowParticles() {
            const flowParticles = workerController.getFlowParticles();
            
            ctx.save();
            
            // Batch similar particles for better rendering performance
            
            // First draw regular particles (no glow, simple circles)
            ctx.shadowBlur = 0;
            for (const particle of flowParticles) {
                if (!particle.glow && particle.shape === 0) {
                    ctx.globalAlpha = particle.alpha;
                    ctx.fillStyle = particle.color;
                    
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Then draw tracer particles with glow (more expensive)
            for (const particle of flowParticles) {
                if (particle.glow || particle.shape !== 0) {
                    ctx.globalAlpha = particle.alpha;
                    
                    // Apply glow only for traced particles
                    if (particle.glow) {
                        ctx.shadowColor = particle.color;
                        ctx.shadowBlur = 3; // Reduced blur size
                    } else {
                        ctx.shadowBlur = 0;
                    }
                    
                    ctx.fillStyle = particle.color;
                    ctx.strokeStyle = particle.color;
                    
                    // Draw trail (if it exists)
                    if (particle.isTracer && particle.trail && particle.trail.length > 0) {
                        ctx.beginPath();
                        ctx.moveTo(particle.x, particle.y);
                        
                        // Simplified trail - no alpha calculations per segment
                        for (const point of particle.trail) {
                            ctx.lineTo(point.x, point.y);
                        }
                        
                        ctx.lineWidth = particle.size * 0.6;
                        ctx.stroke();
                    }
                    
                    // Draw the particle itself
                    if (particle.shape === 0) { // Circle
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    } else { // Line
                        if (particle.vx !== 0 || particle.vy !== 0) {
                            const angle = Math.atan2(particle.vy, particle.vx);
                            const length = particle.size * 2;
                            
                            ctx.beginPath();
                            ctx.moveTo(
                                particle.x - Math.cos(angle) * length, 
                                particle.y - Math.sin(angle) * length
                            );
                            ctx.lineTo(
                                particle.x + Math.cos(angle) * length, 
                                particle.y + Math.sin(angle) * length
                            );
                            ctx.lineWidth = particle.size * 0.7;
                            ctx.stroke();
                        } else {
                            // Fallback to circle
                            ctx.beginPath();
                            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }
            
            ctx.restore();
        }

        function drawEatingParticles() {
            const eatingParticles = workerController.getEatingParticles();
            
            ctx.save();
            
            for (const particle of eatingParticles) {
                ctx.globalAlpha = particle.alpha;
                ctx.fillStyle = particle.color;
                ctx.shadowColor = particle.color;
                ctx.shadowBlur = 3;
                
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function drawFood() {
            const foods = workerController.getFoods();
            
            ctx.save();
            for (const food of foods) {
                // Draw food with glow, using the current scale
                const currentSize = food.size * food.scale;
                
                ctx.globalAlpha = food.alpha;
                ctx.shadowColor = food.color;
                ctx.shadowBlur = 5 * food.scale; // Scale the glow too
                ctx.fillStyle = food.color;
                
                ctx.beginPath();
                ctx.arc(food.x, food.y, currentSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw highlight with proper scaling
                if (food.scale > 0.3) { // Only draw highlight when food is visible enough
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(
                        food.x - currentSize * 0.3, 
                        food.y - currentSize * 0.3, 
                        currentSize * 0.3, 
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        // Create eating effect - now handled by worker controller
        function createEatingEffect(x, y, color) {
            workerController.createEatingEffect(x, y, color);
        }

        // Ambient flow particles system
        const maxFlowParticles = 80;

        function createFlowParticles() {
            // Initialize with fewer particles to start
            const initialParticles = [];
            for (let i = 0; i < maxFlowParticles * 0.6; i++) {
                initialParticles.push(createFlowParticle());
            }
            workerController.setFlowParticles(initialParticles);
        }

        function createFlowParticle() {
            // Simplified particle system - just two types for better performance
            const isTracer = Math.random() < 0.15; // Fewer special particles (15%)
            
            // Create particle at random position, but not too close to edges
            const margin = 50;
            return {
                x: margin + Math.random() * (canvas.width - margin * 2),
                y: margin + Math.random() * (canvas.height - margin * 2),
                // More uniform sizes
                size: isTracer ? 1.5 + Math.random() * 1.5 : 0.8 + Math.random() * 1,
                // Simplified colors - fewer unique color calculations
                color: isTracer 
                    ? `hsla(190, 90%, 80%, ${0.3 + Math.random() * 0.2})` 
                    : `hsla(185, 85%, 75%, ${0.15 + Math.random() * 0.15})`,
                vx: 0,
                vy: 0,
                // Simplified flow parameters
                flowMultiplier: 0.3 + Math.random() * 0.7,
                depthFactor: 0.6 + Math.random() * 1.2,
                // Simplified fade properties
                alpha: 0,
                targetAlpha: isTracer ? 0.4 : 0.2 + Math.random() * 0.15,
                fadeSpeed: 0.01, // Faster fade for fewer update calculations
                // Simplified glow - only tracers glow
                glow: isTracer,
                // Simplified trail system
                isTracer: isTracer,
                // Shorter trails for performance
                trailLength: isTracer ? 3 : 0,
                trail: [], // Will store previous positions
                // Fewer shape variations
                shape: isTracer ? (Math.random() > 0.5 ? 1 : 0) : 0,
                // Simpler lifetime
                lifetime: isTracer ? 400 + Math.random() * 300 : 200 + Math.random() * 300,
                age: 0
            };
        }

        // Add fish on right-click (desktop only)
        canvas.addEventListener('contextmenu', (e) => {
            if (isMobile) return; // Skip on mobile devices
            
            e.preventDefault(); // Prevent context menu from appearing
            
            const fishes = workerController.getFishes();
            if (fishes.length < 150) {
                const newFish = new Fish();
                newFish.x = e.clientX;
                newFish.y = e.clientY;
                
                // Initialize spine points
                for (let i = 0; i < newFish.spinePoints.length; i++) {
                    newFish.spinePoints[i] = {
                        x: newFish.x,
                        y: newFish.y,
                        angle: newFish.angle
                    };
                }
                
                workerController.addFish(newFish);
            }
        });
        
        // Add food on left-click (desktop only)
        canvas.addEventListener('click', (e) => {
            if (isMobile) return; // Skip on mobile devices
            addFood(e.clientX, e.clientY);
        });

        // Animation loop
        function animate(timestamp) {
            // Calculate FPS
            if (!lastFrameTime) {
                lastFrameTime = timestamp;
                lastFpsUpdate = timestamp;
            }
            
            const deltaTime = timestamp - lastFrameTime;
            lastFrameTime = timestamp;
            
            // Increment frame count
            frameCount++;
            
            // Update FPS display every interval
            if (timestamp - lastFpsUpdate >= fpsUpdateInterval) {
                // Calculate average fps over the interval
                fps = Math.round((frameCount * 1000) / (timestamp - lastFpsUpdate));
                fpsCounter.textContent = `FPS: ${fps}`;
                
                // Reset counters
                frameCount = 0;
                lastFpsUpdate = timestamp;
            }

            // Delegate calculation tasks to the worker controller
            workerController.updateFlowParticles(
                canvas.width, canvas.height,
                mouseInfluence, mouseX, mouseY, pmouseX, pmouseY
            );
            
            workerController.updateFood(
                canvas.width, canvas.height,
                mouseInfluence, mouseX, mouseY, pmouseX, pmouseY
            );
            
            workerController.updateEatingParticles(
                canvas.width, canvas.height
            );
            
            workerController.updateFishes(
                canvas.width, canvas.height,
                mouseInfluence, mouseX, mouseY, pmouseX, pmouseY
            );

            // Clear canvas with gradient background
            ctx.fillStyle = background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply slight motion blur for trailing effect
            ctx.fillStyle = 'rgba(0, 0, 25, 0.35)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw flow particles (behind everything)
            drawFlowParticles();
            
            // Draw food
            drawFood();
            
            // Draw eating particles
            drawEatingParticles();
            
            // Get current fishes from worker controller
            const fishesData = workerController.getFishes();
            
            // Sort fish by y-position for proper layering
            const sortedFishesData = [...fishesData].sort((a, b) => a.y - b.y);
            
            // Draw all fish - manually drawing instead of using fish.draw()
            for (const fishData of sortedFishesData) {
                drawFish(fishData);
            }
            
            // Continue animation
            requestAnimationFrame(animate);
        }
        
        // Create a function to draw fish based on fish data
        function drawFish(fishData) {
            const eatBoost = fishData.eatEffectTime > 0 ? 
                Math.sin((fishData.maxEatEffectTime - fishData.eatEffectTime) / fishData.maxEatEffectTime * Math.PI) * 1.5 : 0;
            
            ctx.save();
            
            // Luminosity effect with pulsing
            const glowPulse = 0.7 + Math.sin(fishData.pulsePhase) * 0.3;
            ctx.shadowColor = fishData.color.glow;
            ctx.shadowBlur = (fishData.glowSize + eatBoost * 5) * glowPulse; // Larger glow when eating
            ctx.globalAlpha = (fishData.glow + eatBoost * 0.2) * glowPulse * Math.max(0.6, fishData.energy);
            
            // Luminous body
            drawFishBody(fishData, eatBoost);
            
            // Draw extra glow effect
            ctx.globalAlpha = (0.4 + eatBoost * 0.3) * glowPulse * Math.max(0.6, fishData.energy);
            ctx.shadowBlur = (fishData.glowSize + eatBoost * 8) * 1.5;
            drawFishBody(fishData, eatBoost);
            
            ctx.restore();
        }
        
        function drawFishBody(fishData, eatBoost = 0) {
            // Scale boost for when fish eats (subtle size increase)
            const sizeBoost = 1 + eatBoost * 0.1;
            
            // Calculate points for fish body
            let points = [];
            
            // Draw fish based on spine points
            for (let i = 0; i < fishData.spinePoints.length; i++) {
                const t = i / (fishData.spinePoints.length - 1); // Position along spine (0-1)
                const spine = fishData.spinePoints[i];
                
                // Fish width varies along the length
                let width;
                if (t < 0.3) {
                    // Head to middle (thicken)
                    width = fishData.width * (0.5 + t * 1.5) * sizeBoost;
                } else {
                    // Middle to tail (taper)
                    width = fishData.width * (1 - (t - 0.3) * 1.4) * sizeBoost;
                }
                
                // Only add points for the main body (not the tail)
                if (i < fishData.spinePoints.length - 2) {
                    points.push({
                        x: spine.x,
                        y: spine.y,
                        angle: spine.angle,
                        width: width
                    });
                }
            }
            
            // Draw smooth fish body
            ctx.beginPath();
            
            // Start from the head
            ctx.moveTo(points[0].x, points[0].y);
            
            // Top curve
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const x = p.x + Math.sin(p.angle) * p.width / 2;
                const y = p.y - Math.cos(p.angle) * p.width / 2;
                
                if (i === 0) {
                    ctx.lineTo(x, y);
                } else {
                    // Create smooth curve
                    const prev = points[i-1];
                    const prevX = prev.x + Math.sin(prev.angle) * prev.width / 2;
                    const prevY = prev.y - Math.cos(prev.angle) * prev.width / 2;
                    
                    const cpX = (prevX + x) / 2;
                    const cpY = (prevY + y) / 2;
                    
                    ctx.quadraticCurveTo(cpX, cpY, x, y);
                }
            }
            
            // Add tail tip
            const lastPoint = fishData.spinePoints[fishData.spinePoints.length - 1];
            ctx.lineTo(lastPoint.x, lastPoint.y);
            
            // Bottom curve (in reverse)
            for (let i = points.length - 1; i >= 0; i--) {
                const p = points[i];
                const x = p.x - Math.sin(p.angle) * p.width / 2;
                const y = p.y + Math.cos(p.angle) * p.width / 2;
                
                if (i === points.length - 1) {
                    ctx.lineTo(x, y);
                } else {
                    // Create smooth curve
                    const next = points[i+1];
                    const nextX = next.x - Math.sin(next.angle) * next.width / 2;
                    const nextY = next.y + Math.cos(next.angle) * next.width / 2;
                    
                    const cpX = (nextX + x) / 2;
                    const cpY = (nextY + y) / 2;
                    
                    ctx.quadraticCurveTo(cpX, cpY, x, y);
                }
            }
            
            ctx.closePath();
            
            // Create gradient
            const gradStart = {
                x: fishData.spinePoints[0].x,
                y: fishData.spinePoints[0].y
            };
            
            const gradEnd = {
                x: fishData.spinePoints[fishData.spinePoints.length - 1].x,
                y: fishData.spinePoints[fishData.spinePoints.length - 1].y
            };
            
            const gradient = ctx.createLinearGradient(gradStart.x, gradStart.y, gradEnd.x, gradEnd.y);
            gradient.addColorStop(0, fishData.color.main);
            gradient.addColorStop(0.4, lightenColor(fishData.color.main, 30));
            gradient.addColorStop(1, fishData.color.main);
            
            ctx.fillStyle = gradient;
            ctx.fill();
        }
        
        // Utility function to lighten/darken color
        function lightenColor(color, percent) {
            const num = parseInt(color.slice(1), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, Math.max(0, (num >> 16) + amt));
            const G = Math.min(255, Math.max(0, (num >> 8 & 0x00FF) + amt));
            const B = Math.min(255, Math.max(0, (num & 0x0000FF) + amt));
            return `#${(0x1000000 + (R << 16) + (G << 8) + B).toString(16).slice(1)}`;
        }

        // Initialize the ambient flow particles
        createFlowParticles();

        // Start animation with timestamp
        requestAnimationFrame(animate);
        
        // Handle info panel toggle
        document.addEventListener('DOMContentLoaded', function() {
            const infoPanel = document.getElementById('info-panel');
            const minimizeBtn = document.getElementById('minimize-btn');
            const showInfoBtn = document.getElementById('show-info');
            
            minimizeBtn.addEventListener('click', function() {
                infoPanel.style.display = 'none';
                showInfoBtn.style.display = 'block';
            });
            
            showInfoBtn.addEventListener('click', function() {
                infoPanel.style.display = 'block';
                showInfoBtn.style.display = 'none';
            });
            
            // Auto-hide info panel after 10 seconds on desktop
            if (window.innerWidth > 768) {
                setTimeout(function() {
                    infoPanel.style.opacity = '0.5';
                }, 10000);
                
                infoPanel.addEventListener('mouseenter', function() {
                    infoPanel.style.opacity = '1';
                });
                
                infoPanel.addEventListener('mouseleave', function() {
                    infoPanel.style.opacity = '0.5';
                });
            }
        });
    </script>
    <script>
        window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
    </script>
    <script defer src="/_vercel/insights/script.js"></script>
</body>
</html>
