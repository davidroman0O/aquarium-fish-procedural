<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fish Animation - Three.js Version</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000830;
        }
        canvas {
            display: block;
        }
        #fps {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 16px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 3px;
            z-index: 100;
        }
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 20, 0.7);
            color: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 400px;
            font-size: 14px;
            z-index: 100;
            transition: opacity 0.3s;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .info-panel:hover {
            opacity: 1;
        }
        .info-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #00ffff;
        }
        .info-panel h4 {
            color: #0080ff;
            margin-top: 12px;
            margin-bottom: 5px;
        }
        .info-panel p {
            margin: 5px 0;
        }
        .info-panel ul {
            padding-left: 20px;
            margin: 5px 0;
        }
        .info-panel li {
            margin-bottom: 4px;
        }
        .info-panel a {
            color: #0080ff;
            text-decoration: none;
            transition: color 0.2s;
        }
        .info-panel a:hover {
            color: #ff00ff;
            text-decoration: underline;
        }
        .github-corner {
            position: absolute;
            top: 0;
            right: 0;
            z-index: 100;
        }
        .github-corner svg {
            fill: #0080ff;
            color: #000;
            transition: fill 0.3s;
        }
        .github-corner:hover svg {
            fill: #ff00ff;
        }
        .minimize-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 16px;
        }
        .minimize-btn:hover {
            color: white;
        }
        .show-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 20, 0.7);
            color: rgba(255, 255, 255, 0.8);
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
            display: none;
        }
    </style>
</head>
<body>
    <div id="fps">FPS: 0</div>
    
    <a href="https://github.com/davidroman0O/aquarium-fish-procedural" class="github-corner" aria-label="View on GitHub">
        <svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true">
            <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
            <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
            <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
        </svg>
    </a>
    
    <div id="info-panel" class="info-panel">
        <button id="minimize-btn" class="minimize-btn">Ã—</button>
        <h3>Luminous Fish Simulation</h3>
        <p>A procedural animation of bioluminescent fish in a virtual aquarium.</p>
        
        <h4 id="controls-title">Controls:</h4>
        <div id="desktop-controls">
            <ul>
                <li><strong>Left-click:</strong> Add food particles that attract fish</li>
                <li><strong>Right-click:</strong> Add a new fish at cursor position</li>
                <li><strong>Mouse movement:</strong> Creates gentle water currents</li>
            </ul>
        </div>
        <div id="mobile-controls" style="display: none;">
            <ul>
                <li><strong>Tap:</strong> Add food particles that attract fish</li>
                <li><strong>Double-tap:</strong> Add a new fish at tap position</li>
                <li><strong>Touch and drag:</strong> Creates gentle water currents</li>
            </ul>
        </div>
        
        <h4>About the Flow:</h4>
        <p>The fish move using a dynamic flow system that simulates natural swimming behaviors:</p>
        <ul>
            <li>Each fish has a spine system that provides realistic movement</li>
            <li>Fish are attracted to food when hungry</li>
            <li>Water currents affect both fish and food particles</li>
            <li>Luminosity pulses to simulate bioluminescence</li>
            <li>Fish adapt their swimming patterns based on energy levels</li>
        </ul>
        
        <p><strong>GitHub:</strong> <a href="https://github.com/davidroman0O/aquarium-fish-procedural" target="_blank">davidroman0O/aquarium-fish-procedural</a></p>
    </div>
    
    <div id="show-info" class="show-info">Show Info</div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000418); // Darker blue background like original
        
        // Setup orthographic camera (top-down view)
        const aspectRatio = window.innerWidth / window.innerHeight;
        const viewSize = 400; // Increased viewing area to match original scale
        const camera = new THREE.OrthographicCamera(
            -viewSize * aspectRatio / 2, // left
            viewSize * aspectRatio / 2,  // right
            viewSize / 2,                // top
            -viewSize / 2,               // bottom
            0.1,                         // near
            1000                         // far
        );
        camera.position.z = 100;
        camera.lookAt(0, 0, 0);
        
        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Setup post-processing for bloom effect
        const renderScene = new RenderPass(scene, camera);
        
        // More accurate bloom settings to match original canvas glow - adjusted to be even more subtle
        // TWEAK AREA 1: Bloom settings - adjust these to change the overall glow effect
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.15,   // strength - controls intensity of the bloom (0.1-0.3 for subtle glow)
            0.3,    // radius - affects how far the glow spreads (0.2-0.5 recommended)
            0.6     // threshold - brightness threshold (lower = more colors glow, higher = only bright colors)
        );
        
        const outputPass = new OutputPass();
        
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // Add SMAA anti-aliasing pass for smoother edges
        const smaaPass = new SMAAPass(window.innerWidth, window.innerHeight);
        composer.addPass(smaaPass);

        composer.addPass(outputPass);
        
        // Create custom shader for fish base
        const fishVertexShader = `
            varying vec2 vUv;
            varying vec3 vPosition;
            
            void main() {
                vUv = uv;
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        
        // Base fish shader with more authentic brightness
        const fishFragmentShader = `
            uniform vec3 color;
            varying vec2 vUv;
            varying vec3 vPosition;
            
            // Calculate perceived luminance using the same function as in the glow shader
            float getLuminance(vec3 color) {
                return dot(color, vec3(0.299, 0.587, 0.114));
            }
            
            void main() {
                // Make fish bright but not excessive
                float dist = length(vPosition.xy);
                float edgeFactor = smoothstep(0.6, 1.0, dist / 5.0);
                
                // Get luminance to normalize colors
                float luminance = getLuminance(color);
                
                // TWEAK AREA 4: Base Color Brightness Normalization
                // Controls basic color normalization before pastel effect
                // Increase first value to make darker colors brighter
                float brightnessNormalization = mix(1.2, 1.0, luminance);
                vec3 normalizedColor = color * brightnessNormalization;
                
                // Create more pastel-like colors by mixing with white
                vec3 pastelColor = mix(normalizedColor, vec3(1.0, 1.0, 1.0), 0.2);
                
                // Only slightly brighter in the center
                vec3 brightColor = pastelColor * 1.1; 
                vec3 finalColor = mix(brightColor, pastelColor, edgeFactor * 0.7);
                
                // Output color - fully opaque
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;
        
        // Much more subtle glow shader that better matches canvas original
        const glowFragmentShader = `
            uniform vec3 color;
            uniform float energy;
            uniform float pulsePhase;
            uniform float hunger;
            uniform float eatBoost;
            
            varying vec2 vUv;
            varying vec3 vPosition;
            
            // Calculate perceived luminance of a color (human eye sensitivity differs per channel)
            float getLuminance(vec3 color) {
                return dot(color, vec3(0.299, 0.587, 0.114));
            }
            
            void main() {
                // Calculate distance from center
                float dist = length(vPosition.xy);
                
                // Create fish-shaped glow that follows the edges
                float edgeFactor = smoothstep(0.4, 1.0, dist / 5.0);
                
                // TWEAK AREA 5: Pulse Effect Range
                // Controls the pulsing range (min + amplitude * sin)
                // First value = minimum brightness, second value = pulse amplitude
                float pulse = 0.7 + 0.3 * sin(pulsePhase);
                
                // Get base perceived luminance of the color
                float luminance = getLuminance(color);
                
                // TWEAK AREA 3: Luminance Boost
                // Controls how much darker colors get boosted
                // First value boosts darker colors (higher = more boost)
                // Adjust these to balance glow across colors
                float luminanceBoost = mix(1.8, 1.0, luminance);
                
                // Apply uniform brightening across all colors
                vec3 glowColor = color * luminanceBoost * (1.1 + eatBoost * 0.2);
                
                // TWEAK AREA 6: Hunger Effect Values
                // Controls glow reduction when hungry
                // First value = hungry glow factor, second = full glow factor
                float hungerEffect = hunger > 0.5 ? 0.05 : 0.9;
                
                // TWEAK AREA 8: Base Opacity Value
                // Overall opacity multiplier - affects glow intensity
                // Increase for stronger glow, decrease for subtler effect
                float baseOpacity = (pulse * energy * hungerEffect + eatBoost * 0.2) * 0.4;
                
                // Create authentic glow pattern with proper falloff
                float finalOpacity = mix(0.05 * baseOpacity, baseOpacity, edgeFactor);
                
                // Output color with appropriate opacity
                gl_FragColor = vec4(glowColor, finalOpacity);
            }
        `;

        // Add water flow simulation
        const waterFlow = {
            // Overall water flow direction and strength - further reduced
            baseVx: 0.001, // Reduced from 0.002
            baseVy: 0.0005, // Reduced from 0.001
            // Current flow variation
            vx: 0,
            vy: 0,
            // Target flow variation (we'll smoothly interpolate to this)
            targetVx: 0,
            targetVy: 0,
            // Time until we pick a new target
            changeTimer: 200,
            // Flow field grid - for more realistic water currents
            resolution: 20, // Grid cells across the screen
            flowField: [], // Will hold flow vectors
            // Vortex properties for more natural flow
            vortices: [],
            vortexCount: 2, // Reduced from 3
            vortexChangeTime: 800 // Increased from 500 for slower changes
        };

        // Initialize flow field grid
        function initializeFlowField() {
            waterFlow.flowField = [];
            const cellsX = Math.ceil(viewSize * aspectRatio / waterFlow.resolution);
            const cellsY = Math.ceil(viewSize / waterFlow.resolution);
            
            for (let y = 0; y < cellsY; y++) {
                for (let x = 0; x < cellsX; x++) {
                    waterFlow.flowField.push({
                        x: (x - cellsX/2) * waterFlow.resolution,
                        y: (y - cellsY/2) * waterFlow.resolution,
                        vx: 0,
                        vy: 0
                    });
                }
            }
            
            // Initial vortices
            updateVortices();
        }
        
        // Create/update vortices for more natural flow
        function updateVortices() {
            waterFlow.vortices = [];
            
            for (let i = 0; i < waterFlow.vortexCount; i++) {
                const bounds = viewSize * aspectRatio / 2;
                waterFlow.vortices.push({
                    x: (Math.random() - 0.5) * bounds * 1.5,
                    y: (Math.random() - 0.5) * viewSize * 1.5,
                    strength: (Math.random() - 0.5) * 0.15, // Reduced from 0.2
                    radius: 100 + Math.random() * 120 // Increased size for even gentler gradient
                });
            }
        }

        function updateWaterFlow() {
            // Smoothly move toward target flow - even slower rate
            waterFlow.vx += (waterFlow.targetVx - waterFlow.vx) * 0.001; // Reduced from 0.002
            waterFlow.vy += (waterFlow.targetVy - waterFlow.vy) * 0.001; // Reduced from 0.002
            
            // Decide if we need a new target
            waterFlow.changeTimer--;
            if (waterFlow.changeTimer <= 0) {
                // Even more reduced target variation for gentler flow
                waterFlow.targetVx = (Math.random() - 0.5) * 0.01; // Reduced from 0.02
                waterFlow.targetVy = (Math.random() - 0.5) * 0.01; // Reduced from 0.02
                waterFlow.changeTimer = 300 + Math.random() * 400; // Increased for slower changes
            }
            
            // Update vortices periodically
            waterFlow.vortexChangeTime--;
            if (waterFlow.vortexChangeTime <= 0) {
                updateVortices();
                waterFlow.vortexChangeTime = 800 + Math.random() * 700; // Increased for slower changes
            }
            
            // Update flow field
            updateFlowField();
        }
        
        // Calculate flow at a specific position by interpolating from the grid
        function getFlowAtPosition(x, y) {
            // Base flow - further reduced base values
            let flowX = waterFlow.baseVx * 0.5; // Further reduced base flow
            let flowY = waterFlow.baseVy * 0.5; // Further reduced base flow
            
            // Add current variation with reduced impact
            flowX += waterFlow.vx * 0.3; // Reduced from 0.5 to 0.3
            flowY += waterFlow.vy * 0.3; // Reduced from 0.5 to 0.3
            
            // Add vortex influence - reduced strength
            for (const vortex of waterFlow.vortices) {
                const dx = x - vortex.x;
                const dy = y - vortex.y;
                const distSq = dx*dx + dy*dy;
                const dist = Math.sqrt(distSq);
                
                if (dist < vortex.radius) {
                    // Calculate vortex effect (stronger toward center, but zero at exact center)
                    const factor = (1 - dist/vortex.radius) * (dist / (vortex.radius/5));
                    
                    // Perpendicular flow for vortex - further reduced effect
                    flowX += -dy * factor * vortex.strength * 0.002; // Reduced from 0.003
                    flowY += dx * factor * vortex.strength * 0.002; // Reduced from 0.003
                }
            }
            
            // Add mouse influence if active - with strict limits
            if (mouseInfluence) {
                const dx = x - mouseX;
                const dy = y - mouseY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const mouseDx = mouseX - pmouseX;
                const mouseDy = mouseY - pmouseY;
                const mouseSpeed = Math.sqrt(mouseDx*mouseDx + mouseDy*mouseDy);
                
                if (dist < 100 && mouseSpeed > 0.1) {
                    // Further reduced factor for extremely gentle influence
                    const factor = (1 - dist/100) * 0.0008; // Reduced from 0.001
                    
                    // Cap mouse movement influence
                    const maxMouseInfluence = 0.003; // Reduced from 0.005
                    let mouseInfluenceX = mouseDx * factor;
                    let mouseInfluenceY = mouseDy * factor;
                    
                    const mouseInfluenceSpeed = Math.sqrt(mouseInfluenceX*mouseInfluenceX + mouseInfluenceY*mouseInfluenceY);
                    if (mouseInfluenceSpeed > maxMouseInfluence) {
                        mouseInfluenceX = (mouseInfluenceX / mouseInfluenceSpeed) * maxMouseInfluence;
                        mouseInfluenceY = (mouseInfluenceY / mouseInfluenceSpeed) * maxMouseInfluence;
                    }
                    
                    flowX += mouseInfluenceX;
                    flowY += mouseInfluenceY;
                }
            }
            
            // Cap maximum flow speed to prevent extreme values - much lower cap
            const flowSpeed = Math.sqrt(flowX*flowX + flowY*flowY);
            const maxFlow = 0.03; // Reduced from 0.05
            if (flowSpeed > maxFlow) {
                flowX = (flowX / flowSpeed) * maxFlow;
                flowY = (flowY / flowSpeed) * maxFlow;
            }
            
            // Apply very gentle smoothing to avoid abrupt changes
            if (window.prevFlowX === undefined) {
                window.prevFlowX = flowX;
                window.prevFlowY = flowY;
            }
            
            // Increase smoothing for more gradual transitions
            const smoothedX = window.prevFlowX * 0.95 + flowX * 0.05; // More smoothing (95/5 instead of 90/10)
            const smoothedY = window.prevFlowY * 0.95 + flowY * 0.05; // More smoothing (95/5 instead of 90/10)
            
            // Store for next frame
            window.prevFlowX = smoothedX;
            window.prevFlowY = smoothedY;
            
            return { vx: smoothedX, vy: smoothedY };
        }
        
        // Update the flow field grid
        function updateFlowField() {
            for (const cell of waterFlow.flowField) {
                const flow = getFlowAtPosition(cell.x, cell.y);
                cell.vx = flow.vx;
                cell.vy = flow.vy;
            }
        }
        
        // Mouse influence tracking
        let mouseX = 0;
        let mouseY = 0;
        let pmouseX = 0;
        let pmouseY = 0;
        let mouseInfluence = false;
        
        // Water current particles - visual indicators of water flow
        const currentIndicators = [];
        const MAX_CURRENT_INDICATORS = 120; // Increased from 60 for more detailed flow
        
        // WATER VISUALIZATION SYSTEM - COMPLETE REPLACEMENT
        // Remove all previous water line and streamer code

        // Create distortion field
        let distortionField = null;
        let distortionMaterial = null;
        const FIELD_RESOLUTION = 32;

        function initializeWaterVisualization() {
            // Clear any existing elements
            if (currentIndicators) {
                for (const item of currentIndicators) {
                    if (item.mesh) {
                        scene.remove(item.mesh);
                        item.mesh.geometry.dispose();
                        item.material.dispose();
                    }
                }
                currentIndicators.length = 0;
            }
            
            if (distortionField) {
                scene.remove(distortionField);
                distortionField.geometry.dispose();
                distortionField.material.dispose();
                distortionField = null;
            }
            
            createParticleSystem();
            createDistortionField();
        }

        // Create many tiny particles of different types
        const waterParticles = [];
        const MAX_TOTAL_PARTICLES = 300;

        function createParticleSystem() {
            // Different types of particles
            createSmallParticles(200); // Tiny dust/speck particles
            createMicroBubbles(80);    // Small bubbles
            createGlowingSpecks(20);   // Occasionally glowing specks
        }

        function createSmallParticles(count) {
            const bounds = viewSize * aspectRatio / 2;
            
            for (let i = 0; i < count; i++) {
                const size = 0.05 + Math.random() * 0.15;
                const particle = {
                    x: (Math.random() - 0.5) * bounds * 1.9,
                    y: (Math.random() - 0.5) * viewSize * 1.9,
                    z: -2.0 + Math.random() * 2.0, // Depth variation
                    size: size,
                    color: getParticleColor(0.2),
                    opacity: 0.01 + Math.random() * 0.04,
                    speed: 0.1 + Math.random() * 0.2,
                    mesh: null,
                    type: 'dust',
                    lifetime: 0,
                    maxLifetime: 200 + Math.floor(Math.random() * 300),
                    wobble: {
                        phase: Math.random() * Math.PI * 2,
                        speed: 0.01 + Math.random() * 0.02,
                        amplitude: 0.01 + Math.random() * 0.02
                    }
                };
                
                // Create geometry and material
                const geometry = new THREE.CircleGeometry(particle.size, 4); // Simple squares
                const material = new THREE.MeshBasicMaterial({
                    color: particle.color,
                    transparent: true,
                    opacity: particle.opacity,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                particle.mesh = new THREE.Mesh(geometry, material);
                particle.mesh.position.set(particle.x, particle.y, particle.z);
                particle.mesh.rotation.z = Math.random() * Math.PI;
                scene.add(particle.mesh);
                
                waterParticles.push(particle);
            }
        }

        function createMicroBubbles(count) {
            const bounds = viewSize * aspectRatio / 2;
            
            for (let i = 0; i < count; i++) {
                const size = 0.1 + Math.random() * 0.4;
                const particle = {
                    x: (Math.random() - 0.5) * bounds * 1.9,
                    y: (Math.random() - 0.5) * viewSize * 1.9,
                    z: -1.0 + Math.random(), // Closer to camera than dust
                    size: size,
                    color: getBubbleColor(),
                    opacity: 0.03 + Math.random() * 0.08,
                    speed: 0.15 + Math.random() * 0.35,
                    mesh: null,
                    type: 'bubble',
                    lifetime: 0,
                    maxLifetime: 300 + Math.floor(Math.random() * 200),
                    wobble: {
                        phase: Math.random() * Math.PI * 2,
                        speed: 0.02 + Math.random() * 0.03,
                        amplitude: 0.02 + Math.random() * 0.06
                    },
                    pulse: {
                        phase: Math.random() * Math.PI * 2,
                        speed: 0.03 + Math.random() * 0.04,
                        amount: 0.1 + Math.random() * 0.2
                    }
                };
                
                // Create bubble with gradient effect
                const geometry = new THREE.CircleGeometry(particle.size, 8);
                
                // Add vertex colors for gradient
                const positionAttribute = geometry.getAttribute('position');
                const colors = [];
                const centerColor = new THREE.Color(particle.color).offsetHSL(0, 0, 0.15);
                const edgeColor = new THREE.Color(particle.color);
                
                for (let i = 0; i < positionAttribute.count; i++) {
                    const vertex = new THREE.Vector3();
                    vertex.fromBufferAttribute(positionAttribute, i);
                    
                    // Distance from center (0-1)
                    const distance = vertex.length() / particle.size;
                    
                    // Interpolate colors
                    const color = centerColor.clone().lerp(edgeColor, distance);
                    
                    colors.push(color.r, color.g, color.b);
                }
                
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const material = new THREE.MeshBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: particle.opacity,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                particle.mesh = new THREE.Mesh(geometry, material);
                particle.mesh.position.set(particle.x, particle.y, particle.z);
                scene.add(particle.mesh);
                
                // Store material for animation
                particle.material = material;
                
                waterParticles.push(particle);
            }
        }

        function createGlowingSpecks(count) {
            const bounds = viewSize * aspectRatio / 2;
            
            for (let i = 0; i < count; i++) {
                const size = 0.1 + Math.random() * 0.25;
                const particle = {
                    x: (Math.random() - 0.5) * bounds * 1.9,
                    y: (Math.random() - 0.5) * viewSize * 1.9,
                    z: -0.5 + Math.random() * 0.5, // Even closer to camera
                    size: size,
                    color: getGlowingSpeckColor(),
                    opacity: 0.05 + Math.random() * 0.15,
                    speed: 0.2 + Math.random() * 0.4,
                    mesh: null,
                    type: 'glow',
                    lifetime: 0,
                    maxLifetime: 150 + Math.floor(Math.random() * 100),
                    wobble: {
                        phase: Math.random() * Math.PI * 2,
                        speed: 0.03 + Math.random() * 0.05,
                        amplitude: 0.03 + Math.random() * 0.08
                    },
                    pulse: {
                        phase: Math.random() * Math.PI * 2,
                        speed: 0.04 + Math.random() * 0.06,
                        amount: 0.3 + Math.random() * 0.5
                    },
                    glow: {
                        active: false,
                        duration: 0,
                        maxDuration: 30 + Math.floor(Math.random() * 20),
                        cooldown: 0,
                        maxCooldown: 100 + Math.floor(Math.random() * 200)
                    }
                };
                
                // Create with glow effect
                const geometry = new THREE.CircleGeometry(particle.size, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: particle.color,
                    transparent: true,
                    opacity: particle.opacity,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                particle.mesh = new THREE.Mesh(geometry, material);
                particle.mesh.position.set(particle.x, particle.y, particle.z);
                scene.add(particle.mesh);
                
                // Store material for animation
                particle.material = material;
                
                waterParticles.push(particle);
            }
        }

        function createDistortionField() {
            // Create a grid of points that will be distorted by the water flow
            const bounds = viewSize * aspectRatio / 2;
            const height = viewSize / 2;
            
            // Create a plane with fine resolution
            const geometry = new THREE.PlaneGeometry(
                bounds * 2, 
                height * 2, 
                FIELD_RESOLUTION, 
                FIELD_RESOLUTION
            );
            
            // Custom shader for distortion effect
            const distortionShader = {
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    uniform float time;
                    varying vec2 vUv;
                    
                    void main() {
                        vUv = uv;
                        
                        // Add very subtle sinusoidal movement to create water ripple illusion
                        float amplitude = 0.15;
                        float wavelength = 40.0;
                        float speed = 0.3;
                        
                        // Create overlapping waves with different directions
                        float wave1 = sin((position.x + position.y) / wavelength + time * speed) * amplitude;
                        float wave2 = sin((position.x - position.y) / (wavelength * 0.7) + time * speed * 0.8) * amplitude * 0.7;
                        float wave3 = sin(position.x / (wavelength * 0.5) + time * speed * 1.2) * amplitude * 0.5;
                        
                        // Combine waves for the final displacement
                        float displacementZ = wave1 + wave2 + wave3;
                        
                        // Apply displacement to z coordinate only
                        vec3 newPosition = position + vec3(0.0, 0.0, displacementZ);
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    
                    void main() {
                        // Almost completely transparent with just a hint of blue
                        vec3 waterColor = vec3(0.2, 0.4, 0.7);
                        
                        // Add subtle gradient
                        float opacity = 0.01 + 0.005 * sin(vUv.x * 5.0) * sin(vUv.y * 5.0);
                        
                        gl_FragColor = vec4(waterColor, opacity);
                    }
                `
            };
            
            // Create material and mesh
            distortionMaterial = new THREE.ShaderMaterial({
                uniforms: distortionShader.uniforms,
                vertexShader: distortionShader.vertexShader,
                fragmentShader: distortionShader.fragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            distortionField = new THREE.Mesh(geometry, distortionMaterial);
            distortionField.position.z = -3.0; // Behind everything else
            scene.add(distortionField);
        }

        function getParticleColor(saturation) {
            // Very subtle blue to cyan tones
            const baseColor = new THREE.Color(0x3060a0);
            
            // Adjust hue slightly and reduce saturation
            const hueShift = (Math.random() - 0.5) * 0.1;
            return new THREE.Color().copy(baseColor).offsetHSL(hueShift, -saturation, Math.random() * 0.1);
        }

        function getBubbleColor() {
            // Brighter blue to cyan shades
            const colors = [
                0x2a5caa, // Medium blue
                0x3e7ac9, // Bright blue
                0x5498ff, // Light blue
                0x84d0ff, // Cyan blue
                0xaae4ff  // Light cyan
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function getGlowingSpeckColor() {
            // Brighter, more vibrant colors for glowing specks
            const colors = [
                0x60c0ff, // Bright blue
                0x40a0ff, // Azure
                0x80d0ff, // Light blue
                0xa0e0ff, // Cyan
                0x90c0ff  // Sky blue
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // Convert hex color to RGB vector for shaders
        function hexToRgb(hex) {
            const r = (hex >> 16 & 255) / 255;
            const g = (hex >> 8 & 255) / 255;
            const b = (hex & 255) / 255;
            return new THREE.Vector3(r, g, b);
        }

        function updateWaterVisualization(deltaTime) {
            // Update all particles
            updateWaterParticles(deltaTime);
            
            // Update distortion field time
            if (distortionMaterial) {
                distortionMaterial.uniforms.time.value += deltaTime * 0.5;
            }
        }

        function updateWaterParticles(deltaTime) {
            for (let i = waterParticles.length - 1; i >= 0; i--) {
                const particle = waterParticles[i];
                
                // Update lifetime
                particle.lifetime++;
                
                // Update wobble
                particle.wobble.phase += particle.wobble.speed;
                const wobbleX = Math.sin(particle.wobble.phase) * particle.wobble.amplitude;
                const wobbleY = Math.cos(particle.wobble.phase * 1.3) * particle.wobble.amplitude;
                
                // Get flow at position
                const flow = getFlowAtPosition(particle.x, particle.y);
                
                // Move with flow at particle-specific speed
                particle.x += flow.vx * particle.speed + wobbleX;
                particle.y += flow.vy * particle.speed + wobbleY;
                
                // Screen wrapping
                const bounds = viewSize * aspectRatio / 2;
                if (particle.x < -bounds) particle.x = bounds;
                if (particle.x > bounds) particle.x = -bounds;
                if (particle.y < -viewSize/2) particle.y = viewSize/2;
                if (particle.y > viewSize/2) particle.y = -viewSize/2;
                
                // Update particle position
                if (particle.mesh) {
                    particle.mesh.position.set(particle.x, particle.y, particle.z);
                }
                
                // Type-specific updates
                if (particle.type === 'bubble' || particle.type === 'glow') {
                    // Update pulse (for bubbles and glowing specks)
                    particle.pulse.phase += particle.pulse.speed;
                    const pulse = 1.0 + Math.sin(particle.pulse.phase) * particle.pulse.amount;
                    
                    if (particle.mesh) {
                        particle.mesh.scale.set(pulse, pulse, 1);
                    }
                    
                    // Update flow-based opacity
                    const flowSpeed = Math.sqrt(flow.vx * flow.vx + flow.vy * flow.vy) * 10;
                    const baseOpacity = particle.opacity * (0.7 + Math.min(flowSpeed, 0.5));
                    
                    if (particle.material) {
                        particle.material.opacity = baseOpacity * pulse;
                    }
                    
                    // Special glow effect for glowing specks
                    if (particle.type === 'glow') {
                        // Check if should activate glow
                        if (!particle.glow.active) {
                            particle.glow.cooldown--;
                            if (particle.glow.cooldown <= 0) {
                                particle.glow.active = true;
                                particle.glow.duration = 0;
                            }
                        }
                        
                        // Update active glow
                        if (particle.glow.active) {
                            particle.glow.duration++;
                            
                            // Calculate glow intensity
                            const progress = particle.glow.duration / particle.glow.maxDuration;
                            const glowIntensity = Math.sin(progress * Math.PI); // 0->1->0 sine curve
                            
                            // Apply glow effect
                            const baseColor = new THREE.Color(particle.color);
                            const glowColor = new THREE.Color(0xc0e0ff); // Brighter, whiter blue
                            
                            // Mix colors based on glow intensity
                            particle.material.color.copy(baseColor).lerp(glowColor, glowIntensity * 0.7);
                            
                            // Increase opacity during glow
                            particle.material.opacity = baseOpacity * (1.0 + glowIntensity * 2.0);
                            
                            // End glow and start cooldown
                            if (particle.glow.duration >= particle.glow.maxDuration) {
                                particle.glow.active = false;
                                particle.glow.cooldown = particle.glow.maxCooldown;
                                
                                // Reset color
                                particle.material.color.set(particle.color);
                            }
                        }
                    }
                }
                
                // Check if particle should be regenerated
                if (particle.lifetime >= particle.maxLifetime) {
                    // Regenerate at a new position
                    const bounds = viewSize * aspectRatio / 2;
                    particle.x = (Math.random() - 0.5) * bounds * 1.9;
                    particle.y = (Math.random() - 0.5) * viewSize * 1.9;
                    particle.lifetime = 0;
                    
                    // Randomize lifetime
                    if (particle.type === 'dust') {
                        particle.maxLifetime = 200 + Math.floor(Math.random() * 300);
                    } else if (particle.type === 'bubble') {
                        particle.maxLifetime = 300 + Math.floor(Math.random() * 200);
                    } else {
                        particle.maxLifetime = 150 + Math.floor(Math.random() * 100);
                    }
                    
                    // Reset glow properties for glowing specks
                    if (particle.type === 'glow') {
                        particle.glow.active = false;
                        particle.glow.cooldown = particle.glow.maxCooldown;
                        particle.material.color.set(particle.color);
                    }
                }
            }
        }

        function createCurrentIndicators() {
            // This function is no longer used, but kept for compatibility
            // The new system uses createParticleSystem() instead
        }

        function updateCurrentIndicators(deltaTime) {
            // This function is no longer used, but kept for compatibility
            // The new system uses updateWaterParticles() instead
        }

        // Food system
        const foods = [];

        function addFood(x, y) {
            for (let i = 0; i < 5; i++) {
                foods.push({
                    id: Date.now() + i, // Add unique ID to each food
                    x: x + (Math.random() - 0.5) * 10,
                    y: y + (Math.random() - 0.5) * 10,
                    size: 0.5 + Math.random() * 0.3, // Reduced food size
                    energy: 10 + Math.random() * 5,
                    color: 0xffcc66,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: (Math.random() - 0.5) * 0.3,
                    alpha: 1.0,
                    scale: 0.01,
                    targetScale: 1.0,
                    scaleSpeed: 0.04 + Math.random() * 0.02,
                    flowMultiplier: 0.7 + Math.random() * 0.6,
                    mesh: null
                });
            }
            
            // Create meshes for the new food particles
            createFoodMeshes();
        }

        function createFoodMeshes() {
            for (const food of foods) {
                if (food.mesh === null) {
                    // Create a simple circle geometry for food
                    const geometry = new THREE.CircleGeometry(food.size, 8);
                    const material = new THREE.MeshBasicMaterial({
                        color: food.color,
                        transparent: true,
                        opacity: food.alpha
                    });
                    
                    // Create mesh and add to scene
                    food.mesh = new THREE.Mesh(geometry, material);
                    food.mesh.position.set(food.x, food.y, 0);
                    food.mesh.scale.set(food.scale, food.scale, 1);
                    scene.add(food.mesh);
                }
            }
        }

        function updateFood() {
            for (let i = foods.length - 1; i >= 0; i--) {
                const food = foods[i];
                
                // Update scale animation with easing
                if (food.scale < food.targetScale) {
                    food.scale += (food.targetScale - food.scale) * food.scaleSpeed;
                    if (food.mesh) {
                        food.mesh.scale.set(food.scale, food.scale, 1);
                    }
                }
                
                // Apply water resistance/drag
                food.vx *= 0.98;
                food.vy *= 0.98;
                
                // Get flow at this position for more realistic movement
                const flow = getFlowAtPosition(food.x, food.y);
                
                // Apply flow with multiplier
                food.vx += flow.vx * food.flowMultiplier;
                food.vy += flow.vy * food.flowMultiplier;
                
                // Add some random movement
                food.vx += (Math.random() - 0.5) * 0.01;
                food.vy += (Math.random() - 0.5) * 0.01;
                
                // Cap maximum velocity
                const maxVelocity = 0.7;
                const currentVelocity = Math.sqrt(food.vx * food.vx + food.vy * food.vy);
                if (currentVelocity > maxVelocity) {
                    food.vx = (food.vx / currentVelocity) * maxVelocity;
                    food.vy = (food.vy / currentVelocity) * maxVelocity;
                }
                
                // Update position
                food.x += food.vx;
                food.y += food.vy;
                
                if (food.mesh) {
                    food.mesh.position.set(food.x, food.y, 0);
                }
                
                // Fade out if near edges
                const edgeDistance = Math.min(
                    food.x - (-viewSize * aspectRatio / 2),
                    food.y - (-viewSize / 2),
                    (viewSize * aspectRatio / 2) - food.x,
                    (viewSize / 2) - food.y
                );
                
                if (edgeDistance < 20) {
                    food.alpha -= 0.02;
                    if (food.mesh) {
                        food.mesh.material.opacity = food.alpha;
                    }
                }
                
                // Remove if fully faded or off screen
                if (food.alpha <= 0 || 
                    food.x < -viewSize * aspectRatio / 2 - 10 || 
                    food.x > viewSize * aspectRatio / 2 + 10 || 
                    food.y < -viewSize / 2 - 10 || 
                    food.y > viewSize / 2 + 10) {
                    
                    // Remove mesh from scene
                    if (food.mesh) {
                        scene.remove(food.mesh);
                        food.mesh.geometry.dispose();
                        food.mesh.material.dispose();
                    }
                    
                    foods.splice(i, 1);
                }
            }
        }

        // Fish class - with added intelligence
        class Fish {
            constructor() {
                // TWEAK AREA 11: Fish Size Range
                // Adjust these values to change how big or small fish can be
                const minFishLength = 5;  // Minimum fish length
                const maxFishLength = 13; // Maximum fish length
                
                // Fish properties
                this.length = minFishLength + Math.random() * (maxFishLength - minFishLength);
                this.width = this.length * 0.3; // Increased width ratio to match original
                this.spineSegments = 10;
                
                // Position and movement - now size-dependent for more realism
                this.position = new THREE.Vector3(0, 0, 0);
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.angle = Math.random() * Math.PI * 2;
                
                // TWEAK AREA 9: Size-Speed Relationship
                // Calculate size factor (0-1) where 0 = smallest possible fish, 1 = largest possible fish
                const sizeFactor = (this.length - minFishLength) / (maxFishLength - minFishLength);
                
                // Speed increases with size (bigger fish swim faster but turn slower)
                this.targetVelocity = 0.8 + sizeFactor * 1.5; // Range: 0.8-2.3
                
                // Turning speed decreases with size (smaller fish turn faster)
                this.turnSpeed = (0.04 - sizeFactor * 0.02) * (1 + Math.random() * 0.5); // Range: ~0.02-0.04
                
                // Acceleration decreases with size (smaller fish accelerate faster)
                this.turnAcceleration = (0.04 - sizeFactor * 0.02) * (1 + Math.random() * 0.5); // Range: ~0.02-0.04
                
                // Swimming motion
                this.swimPhase = Math.random() * Math.PI * 2;
                this.swimSpeed = 0.05 + Math.random() * 0.05; // Matched original
                this.swimAmplitude = 0.15 + Math.random() * 0.1; // Matched original
                
                // Intelligence - behavior parameters
                this.energy = 0.7 + Math.random() * 0.3;
                this.hungry = false;
                this.huntingTarget = null;
                this.timeToNextHunger = 500 + Math.random() * 1000;
                
                // Fish turning mechanics
                this.vx = 0;
                this.vy = 0;
                this.targetVx = 0;
                this.targetVy = 0;
                this.targetAngle = this.angle;
                this.turnDirection = 0; // -1 left, 0 straight, 1 right
                this.turnTimer = 0;
                this.commitMove = 0;
                this.commitMax = 5;
                this.directionCounter = 0;
                
                // Targeting behavior
                this.targetChangeTimer = 0;
                this.targetX = this.position.x;
                this.targetY = this.position.y;
                this.wanderAngle = Math.random() * Math.PI * 2;
                this.wanderSpeed = 0.01 + Math.random() * 0.03;
                
                // Color
                this.color = this.getRandomColor();
                
                // Add eating animation effect similar to original
                this.eatEffectTime = 0;
                this.maxEatEffectTime = 25; // How long the eating effect lasts
                
                // Death state and animation
                this.isDying = false;
                this.isDead = false;
                this.deathTime = 0;
                this.deathDuration = 120; // 2 seconds at 60fps
                this.chasingFood = false;
                this.criticalEnergyLevel = 0.1; // Energy level that triggers death
                this.chasedFoodId = null; // Track which food item we're chasing
                
                // Create the fish
                this.createFishMesh();
            }
            
            getRandomColor() {
                // TWEAK AREA 2: Fish Color Palette
                // Adjust these colors to change fish appearance
                // Format: 0xRRGGBB - higher values = brighter colors
                const colors = [
                    0x40ffff, // Cyan (brightened)
                    0xff40ff, // Magenta (brightened)
                    0xffff40, // Yellow (dimmed slightly)
                    0xff9040, // Orange (brightened)
                    0x60ff60, // Green (brightened)
                    0xff5090, // Pink (brightened)
                    0x40a0ff  // Light blue (brightened)
                ];
                
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            createFishMesh() {
                // Create custom geometry for the fish
                const geometry = new THREE.BufferGeometry();
                
                // Parameters for fish shape
                const length = this.length;
                const width = this.width;
                const segments = this.spineSegments;
                
                // Create buffer for positions, and indices
                const vertices = [];
                const indices = [];
                
                // Create a simpler leaf-shaped fish with proper teardrop profile
                // Points along the spine
                const spinePoints = [];
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const x = length/2 - t * length;
                    spinePoints.push(x);
                }
                
                // Generate all vertices for fish shape
                this.vertexMap = [];
                
                // Create top edge vertices
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const x = spinePoints[i];
                    
                    // Create a teardrop profile
                    let w = width;
                    if (t < 0.3) {
                        // Create more pointed head with a curved taper
                        w = width * (0.4 + Math.sqrt(t) * 1.4); 
                    } else {
                        // Tail tapers more gradually
                        w = width * (1 - (t - 0.3) * 1.1);
                    }
                    
                    // Make the tail end extra slender
                    if (t > 0.85) {
                        w *= (1 - (t - 0.85) * 3.5);
                    }
                    
                    // Top edge
                    const y = w / 2;
                    vertices.push(x, y, 0);
                    
                    this.vertexMap.push({
                        segmentIndex: i,
                        isTopEdge: true,
                        position: new THREE.Vector3(x, y, 0),
                        vertexIndex: vertices.length / 3 - 1
                    });
                }
                
                // Create bottom edge vertices (in reverse order)
                for (let i = segments; i >= 0; i--) {
                    const t = i / segments;
                    const x = spinePoints[i];
                    
                    // Match the profile from top edge
                    let w = width;
                    if (t < 0.3) {
                        w = width * (0.4 + Math.sqrt(t) * 1.4);
                    } else {
                        w = width * (1 - (t - 0.3) * 1.1);
                    }
                    
                    if (t > 0.85) {
                        w *= (1 - (t - 0.85) * 3.5);
                    }
                    
                    // Bottom edge
                    const y = -w / 2;
                    vertices.push(x, y, 0);
                    
                    this.vertexMap.push({
                        segmentIndex: i,
                        isTopEdge: false,
                        position: new THREE.Vector3(x, y, 0),
                        vertexIndex: vertices.length / 3 - 1
                    });
                }
                
                // Triangulate the fish body
                const numTop = segments + 1;
                const totalVerts = numTop * 2;
                
                // Create triangles to fill the body
                for (let i = 0; i < segments; i++) {
                    // Connect top edge to bottom edge
                    const topLeft = i;
                    const topRight = i + 1;
                    const bottomLeft = totalVerts - i - 1;
                    const bottomRight = totalVerts - i - 2;
                    
                    // Add two triangles to form a quad
                    indices.push(topLeft, topRight, bottomRight);
                    indices.push(topLeft, bottomRight, bottomLeft);
                }
                
                // Set geometry attributes
                geometry.setIndex(indices);
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(vertices, 2));
                
                // Create material for base fish
                const baseMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        color: { value: hexToRgb(this.color) }
                    },
                    vertexShader: fishVertexShader,
                    fragmentShader: fishFragmentShader,
                    side: THREE.DoubleSide
                });
                
                // Create the base fish mesh
                this.mesh = new THREE.Mesh(geometry, baseMaterial);
                this.positions = this.mesh.geometry.attributes.position;
                scene.add(this.mesh);
                
                // Initialize spine points
                this.spinePoints = [];
                this.initializeSpine();
                
                // Add shader attributes for glow
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.pulseSpeed = 0.04 + Math.random() * 0.03;
                this.hungerFactor = 0.0; // 0 = full, 1 = hungry
                
                // Create glow layer mesh (with same geometry)
                const glowGeometry = geometry.clone();
                const glowMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        color: { value: hexToRgb(this.color) },
                        energy: { value: this.energy },
                        pulsePhase: { value: this.pulsePhase },
                        hunger: { value: this.hungerFactor },
                        eatBoost: { value: 0.0 }
                    },
                    vertexShader: fishVertexShader,
                    fragmentShader: glowFragmentShader,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                // Create the glow mesh
                this.glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                this.glowPositions = this.glowMesh.geometry.attributes.position;
                
                // Add the glow mesh directly to the scene
                scene.add(this.glowMesh);
            }
            
            initializeSpine() {
                // Create spine points for animation - track position AND angle like in the original
                for (let i = 0; i <= this.spineSegments; i++) {
                    this.spinePoints.push({
                        x: this.position.x,
                        y: this.position.y,
                        initialX: this.length * (0.5 - i / this.spineSegments),
                        angle: this.angle,
                        offsetY: 0
                    });
                }
            }
            
            update(deltaTime) {
                // Don't update if already dead and animation complete
                if (this.isDead && this.deathTime >= this.deathDuration) {
                    return;
                }
                
                // Handle death animation if dying
                if (this.isDying) {
                    this.updateDeathAnimation(deltaTime);
                    return;
                }
                
                // Scale deltaTime to make animation speed consistent
                // CRITICAL FIX: Cap deltaTime to prevent extreme jumps in physics when frames drop
                const maxDeltaTime = 0.05; // 50ms max (20fps)
                deltaTime = Math.min(deltaTime, maxDeltaTime);
                const timeScale = deltaTime * 60; // Normalize to ~60fps equivalent
                
                // Process appearance animation if active
                if (this.appearanceAnimation && this.appearanceAnimation.active) {
                    this.appearanceAnimation.progress++;
                    
                    // Calculate eased progress
                    const progress = this.appearanceAnimation.progress / this.appearanceAnimation.duration;
                    
                    // Ease-out function for smooth growth and fade in
                    const eased = 1 - Math.pow(1 - progress, 3); // Cubic ease out
                    
                    // Apply scale 
                    const currentScale = this.appearanceAnimation.targetScale * eased;
                    this.mesh.scale.set(currentScale, currentScale, 1);
                    this.glowMesh.scale.set(currentScale, currentScale, 1);
                    
                    // Apply opacity
                    const currentOpacity = this.appearanceAnimation.startOpacity + 
                                          (this.appearanceAnimation.targetOpacity - this.appearanceAnimation.startOpacity) * eased;
                    this.mesh.material.opacity = currentOpacity;
                    
                    // Complete animation
                    if (this.appearanceAnimation.progress >= this.appearanceAnimation.duration) {
                        this.appearanceAnimation.active = false;
                        this.mesh.material.transparent = false;
                        this.mesh.material.opacity = 1;
                        this.mesh.scale.set(1, 1, 1);
                        this.glowMesh.scale.set(1, 1, 1);
                    }
                }
                
                // Update energy and hunger
                this.timeToNextHunger--;
                if (this.timeToNextHunger <= 0) {
                    this.hungry = true;
                    this.energy = Math.max(this.criticalEnergyLevel / 2, this.energy - 0.1);
                    this.timeToNextHunger = 500 + Math.random() * 500;
                    
                    // Check if energy is too low and fish should die
                    // Exception: If currently chasing food, give it a chance
                    if (this.energy <= this.criticalEnergyLevel && !this.chasingFood) {
                        this.startDying();
                        return;
                    }
                }
                
                // Check for food if hungry
                if (this.hungry) {
                    this.checkForFood();
                }
                
                // If we were chasing food but it's gone from the array, we failed to get it
                if (this.chasingFood && this.chasedFoodId !== null) {
                    const foodStillExists = foods.some(food => food.id === this.chasedFoodId);
                    if (!foodStillExists) {
                        // We were chasing food but it disappeared (eaten by another fish or went off-screen)
                        this.chasingFood = false;
                        this.chasedFoodId = null;
                        
                        // If energy is critical, start dying
                        if (this.energy <= this.criticalEnergyLevel) {
                            this.startDying();
                            return;
                        }
                    }
                }
                
                // Update swimming animation
                this.swimPhase += this.swimSpeed * this.energy;
                
                // Update pulse phase for glow effect
                this.pulsePhase += this.pulseSpeed;
                
                // Update hunger factor based on energy level
                // When energy drops below half of critical level, glow should be 0
                const halfCritical = this.criticalEnergyLevel / 2; // Half of critical energy (0.05)
                
                if (this.energy <= halfCritical) {
                    // No glow at all below half critical
                    this.hungerFactor = 1.0;
                } else if (this.energy <= this.criticalEnergyLevel) {
                    // Linear fade between half-critical and critical
                    const t = (this.energy - halfCritical) / halfCritical;
                    this.hungerFactor = 0.98 - t * 0.5; // Fade from 0.98 to 0.48
                } else if (this.hungry) {
                    // Hungry but not critical - reduced glow
                    this.hungerFactor = 0.6;
                } else {
                    // Normal - full glow
                    this.hungerFactor = 0.05;
                }
                
                // Update eat effect timer
                if (this.eatEffectTime > 0) {
                    this.eatEffectTime--;
                }
                
                // Update mesh position and orientation
                this.mesh.position.set(this.position.x, this.position.y, 0);
                this.mesh.rotation.z = this.angle;
                
                // Update glow mesh separately - exact same position
                this.glowMesh.position.set(this.position.x, this.position.y, 0);
                this.glowMesh.rotation.z = this.angle;
                
                // Update glow uniforms
                if (this.glowMesh.material.uniforms) {
                    this.glowMesh.material.uniforms.pulsePhase.value = this.pulsePhase;
                    this.glowMesh.material.uniforms.energy.value = this.energy;
                    this.glowMesh.material.uniforms.hunger.value = this.hungerFactor;
                    
                    // TWEAK AREA 7: Eat Boost Effect
                    // Controls eating glow boost intensity (higher = brighter flash)
                    const eatBoost = this.eatEffectTime > 0 ? 
                        Math.sin((this.maxEatEffectTime - this.eatEffectTime) / this.maxEatEffectTime * Math.PI) * 1.5 : 0;
                    this.glowMesh.material.uniforms.eatBoost.value = eatBoost;
                }
                
                // Decide on movement target
                this.targetChangeTimer--;
                if (this.targetChangeTimer <= 0) {
                    this.updateTarget();
                }
                
                // Calculate direction to target
                let targetAngle;
                
                if (mouseInfluence && Math.random() < 0.005) {
                    // Occasionally be attracted to mouse
                    const dx = mouseX - this.position.x;
                    const dy = mouseY - this.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 100) {
                        targetAngle = Math.atan2(dy, dx);
                        // Increase speed when following mouse - but with a reasonable cap
                        // CRITICAL FIX: Prevent extreme multiplication of speed
                        const defaultVelocity = 0.8 + (this.length - 5) / (13 - 5) * 1.5;
                        this.targetVelocity = Math.min(defaultVelocity * 2.0, 4.0); // Cap at 4.0
                    } else {
                        targetAngle = Math.atan2(this.targetY - this.position.y, this.targetX - this.position.x);
                        // Return to normal speed based on size
                        const minFishLength = 5;  // Should match constructor value
                        const maxFishLength = 13; // Should match constructor value
                        const sizeFactor = (this.length - minFishLength) / (maxFishLength - minFishLength);
                        this.targetVelocity = 0.8 + sizeFactor * 1.5;
                    }
                } else {
                    targetAngle = Math.atan2(this.targetY - this.position.y, this.targetX - this.position.x);
                }
                
                // Improved turning mechanics
                let angleDiff = targetAngle - this.angle;
                
                // Normalize angle difference to range [-PI, PI]
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                
                // Apply turning with commitment behavior - match original values
                if (this.commitMove < 0) {
                    this.angle -= this.turnSpeed * 1.5 * timeScale;
                    this.commitMove += 1;
                    this.turnDirection = -1;
                } else if (this.commitMove > 0) {
                    this.angle += this.turnSpeed * 1.5 * timeScale;
                    this.commitMove -= 1;
                    this.turnDirection = 1;
                } else if (angleDiff > 0.1) {
                    this.angle += this.turnSpeed * this.energy * timeScale;
                    this.turnDirection = 1;
                    
                    // Sometimes commit to a turn
                    if (this.directionCounter > 0) {
                        this.directionCounter++;
                        if (this.directionCounter > 2 * this.commitMax) {
                            this.commitMove = 1 + Math.floor(this.commitMax / 3);
                            this.directionCounter = 0;
                        }
                    } else {
                        this.directionCounter = 1;
                    }
                } else if (angleDiff < -0.1) {
                    this.angle -= this.turnSpeed * this.energy * timeScale;
                    this.turnDirection = -1;
                    
                    // Sometimes commit to a turn
                    if (this.directionCounter < 0) {
                        this.directionCounter--;
                        if (this.directionCounter < -2 * this.commitMax) {
                            this.commitMove = -1 - Math.floor(this.commitMax / 3);
                            this.directionCounter = 0;
                        }
                    } else {
                        this.directionCounter = -1;
                    }
                } else {
                    // Close enough to target angle, apply small correction
                    this.angle += angleDiff * this.turnSpeed * 0.5 * timeScale;
                    this.turnDirection = 0;
                }
                
                // Calculate target velocity with proper acceleration
                this.targetVx = Math.cos(this.angle) * this.targetVelocity * this.energy;
                this.targetVy = Math.sin(this.angle) * this.targetVelocity * this.energy;
                
                // Smoothly apply acceleration - match original values
                this.velocity.x += (this.targetVx - this.velocity.x) * this.turnAcceleration * timeScale;
                this.velocity.y += (this.targetVy - this.velocity.y) * this.turnAcceleration * timeScale;
                
                // Get local flow and apply influence - more realistic water flow
                const flow = getFlowAtPosition(this.position.x, this.position.y);
                const flowInfluence = 0.3 + (1 - this.energy) * 0.4; // Tired fish are more affected by flow
                this.velocity.x += flow.vx * flowInfluence;
                this.velocity.y += flow.vy * flowInfluence;
                
                // CRITICAL FIX: Cap maximum velocity to prevent fish going too fast
                const currentVelocity = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
                const maxVelocity = this.targetVelocity * 1.5; // Cap at 150% of target velocity
                if (currentVelocity > maxVelocity) {
                    this.velocity.x = (this.velocity.x / currentVelocity) * maxVelocity;
                    this.velocity.y = (this.velocity.y / currentVelocity) * maxVelocity;
                }
                
                // TWEAK AREA 10: Movement Speed Scaling
                // Increase this multiplier to make all fish move faster
                const speedMultiplier = 0.15; // Increased from 0.1 for faster movement
                
                // Move the fish with deltaTime scaling
                this.position.x += this.velocity.x * timeScale * speedMultiplier;
                this.position.y += this.velocity.y * timeScale * speedMultiplier;
                
                // Screen wrapping (similar to original)
                const bounds = viewSize * aspectRatio / 2;
                if (this.position.x < -bounds - this.length) this.position.x = bounds + this.length;
                if (this.position.x > bounds + this.length) this.position.x = -bounds - this.length;
                if (this.position.y < -viewSize/2 - this.length) this.position.y = viewSize/2 + this.length;
                if (this.position.y > viewSize/2 + this.length) this.position.y = -viewSize/2 - this.length;
                
                // Update mesh position and orientation
                this.mesh.position.set(this.position.x, this.position.y, 0);
                this.mesh.rotation.z = this.angle;
                
                // Update spine animation with realistic propagation like in the original
                this.updateSpine(timeScale);
                
                // Update vertices for both meshes
                this.updateMeshFromSpine();
            }
            
            checkForFood() {
                for (let i = foods.length - 1; i >= 0; i--) {
                    const food = foods[i];
                    const dx = food.x - this.position.x;
                    const dy = food.y - this.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // If close enough to eat
                    if (dist < this.width) {
                        // Consume food and gain energy
                        this.energy = Math.min(1.0, this.energy + food.energy/100);
                        this.hungry = false;
                        this.targetChangeTimer = 0;
                        this.chasingFood = false;
                        this.chasedFoodId = null;
                        
                        // Trigger eating animation effect
                        this.eatEffectTime = this.maxEatEffectTime;
                        
                        // Create food consumption animation effect
                        createFoodConsumptionEffect(food, this);
                        
                        // Remove the food
                        if (food.mesh) {
                            scene.remove(food.mesh);
                            food.mesh.geometry.dispose();
                            food.mesh.material.dispose();
                        }
                        foods.splice(i, 1);
                        break;
                    } else if (dist < 100) {
                        // Chase nearby food
                        this.targetX = food.x;
                        this.targetY = food.y;
                        this.targetChangeTimer = 10;
                        this.chasingFood = true;
                        this.chasedFoodId = food.id;
                        
                        // Move faster when chasing food, but with a speed cap
                        const chaseFactor = 1.5;
                        const chaseVelocity = this.targetVelocity * this.energy * chaseFactor;
                        // CRITICAL FIX: Prevent unreasonable chase speeds
                        const maxChaseVelocity = 4.0; // Same cap as mouse interaction
                        this.targetVx = Math.cos(this.angle) * Math.min(chaseVelocity, maxChaseVelocity);
                        this.targetVy = Math.sin(this.angle) * Math.min(chaseVelocity, maxChaseVelocity);
                    }
                }
            }
            
            updateTarget() {
                // How long until we change target again
                this.targetChangeTimer = 100 + Math.random() * 200;
                
                // Check for food if hungry
                if (this.hungry && foods.length > 0) {
                    let closest = Infinity;
                    let closestFood = null;
                    
                    for (const food of foods) {
                        const dx = food.x - this.position.x;
                        const dy = food.y - this.position.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < closest && dist < 150) {
                            closest = dist;
                            closestFood = food;
                        }
                    }
                    
                    if (closestFood) {
                        this.targetX = closestFood.x;
                        this.targetY = closestFood.y;
                        return;
                    }
                }
                
                // If not targeting food, choose a new wandering target
                // Choose a new target with smooth wandering
                this.wanderAngle += (Math.random() - 0.5) * 0.3;
                
                // Center of canvas plus wander offset
                const centerX = 0;
                const centerY = 0;
                const wanderRadius = Math.min(viewSize, viewSize * aspectRatio) * 0.3;
                
                this.targetX = centerX + Math.cos(this.wanderAngle) * wanderRadius;
                this.targetY = centerY + Math.sin(this.wanderAngle) * wanderRadius;
                
                // Add some randomness
                this.targetX += (Math.random() - 0.5) * 50;
                this.targetY += (Math.random() - 0.5) * 50;
                
                // Keep within screen bounds
                const margin = 50;
                const bounds = viewSize * aspectRatio / 2;
                this.targetX = Math.max(-bounds + margin, Math.min(bounds - margin, this.targetX));
                this.targetY = Math.max(-viewSize/2 + margin, Math.min(viewSize/2 - margin, this.targetY));
            }
            
            updateSpine(timeScale) {
                // Update first spine point to current fish position and angle
                this.spinePoints[0] = {
                    x: this.position.x,
                    y: this.position.y,
                    angle: this.angle,
                    initialX: this.spinePoints[0].initialX,
                    offsetY: 0
                };
                
                // Update remaining spine points with position and angle delay like in original
                for (let i = 1; i <= this.spineSegments; i++) {
                    const prev = this.spinePoints[i-1];
                    const curr = this.spinePoints[i] || { angle: this.angle };
                    
                    // Distance between spine points
                    const segmentLength = this.length / this.spineSegments;
                    
                    // Calculate target angle with swim wiggle (stronger when turning)
                    const turnFactor = Math.abs(this.turnDirection) * 1.5;
                    const swimWiggle = Math.sin(this.swimPhase - i * 0.3) * 
                                      this.swimAmplitude * 
                                      (i / this.spineSegments) * 
                                      (1 + turnFactor);
                    
                    // Set target angle based on previous segment plus wiggle
                    const targetAngle = prev.angle + swimWiggle;
                    
                    // Smooth angle transition
                    if (!curr.angle) curr.angle = this.angle;
                    curr.angle = curr.angle + (targetAngle - curr.angle) * 0.2 * timeScale;
                    
                    // Calculate new position based on previous point, angle and segment length
                    const nextX = prev.x - Math.cos(curr.angle) * segmentLength;
                    const nextY = prev.y - Math.sin(curr.angle) * segmentLength;
                    
                    // Store updated values
                    this.spinePoints[i] = {
                        x: nextX,
                        y: nextY,
                        angle: curr.angle,
                        initialX: this.spinePoints[i] ? this.spinePoints[i].initialX : -segmentLength * i,
                        offsetY: Math.sin(this.swimPhase - i * 0.3) * this.swimAmplitude * (i / this.spineSegments) * this.width
                    };
                }
            }
            
            updateMeshFromSpine() {
                // Skip if no vertex map
                if (!this.vertexMap || !this.positions) return;
                
                // Update all vertices based on spine deformation
                for (const vertex of this.vertexMap) {
                    // Get the spine point that controls this vertex
                    const spinePoint = this.spinePoints[vertex.segmentIndex];
                    
                    if (!spinePoint) continue;
                    
                    // Original position in local space
                    const localPos = vertex.position.clone();
                    
                    // Calculate the vertex position in world space
                    // This creates a more natural deformation following the spine curve
                    
                    // 1. Calculate distance from spine (width based on original width profile)
                    let widthFactor = 1;
                    const t = vertex.segmentIndex / this.spineSegments;
                    
                    if (t < 0.3) {
                        // Create more pointed head with a curved taper
                        widthFactor = 0.4 + Math.sqrt(t) * 1.4;
                    } else {
                        // Tail tapers more gradually
                        widthFactor = 1 - (t - 0.3) * 1.1;
                    }
                    
                    if (t > 0.85) {
                        widthFactor *= (1 - (t - 0.85) * 3.5);
                    }
                    
                    // 2. Calculate offset perpendicular to spine based on spine angle
                    const width = this.width * widthFactor;
                    const sideOffset = vertex.isTopEdge ? width/2 : -width/2;
                    
                    // 3. Calculate final position by offsetting from spine location perpendicular to spine angle
                    const offsetX = Math.sin(spinePoint.angle) * sideOffset;
                    const offsetY = -Math.cos(spinePoint.angle) * sideOffset;
                    
                    // Update vertex position - convert from world to local coordinates
                    const worldX = spinePoint.x + offsetX - this.position.x;
                    const worldY = spinePoint.y + offsetY - this.position.y;
                    
                    // Rotate point to be in local space of the rotated mesh
                    const rotation = -this.angle; // Negative because we're going from world to local
                    const localX = worldX * Math.cos(rotation) - worldY * Math.sin(rotation);
                    const localY = worldX * Math.sin(rotation) + worldY * Math.cos(rotation);
                    
                    // Apply the new coordinates to base mesh
                    this.positions.setXYZ(
                        vertex.vertexIndex,
                        localX,
                        localY,
                        0
                    );
                    
                    // Apply same coordinates to glow mesh
                    if (this.glowPositions) {
                        this.glowPositions.setXYZ(
                            vertex.vertexIndex,
                            localX,
                            localY,
                            0
                        );
                    }
                }
                
                // Mark both meshes as needing update
                this.positions.needsUpdate = true;
                if (this.glowPositions) {
                    this.glowPositions.needsUpdate = true;
                }
            }
            
            updateDeathAnimation(deltaTime) {
                // Death animation: fish floats to the top while fading out and shrinking
                this.deathTime++;
                
                // Calculate progress of death animation (0-1)
                const progress = Math.min(this.deathTime / this.deathDuration, 1.0);
                
                // Slow down swimming motion
                this.swimSpeed = 0.05 * (1 - progress * 0.8);
                
                // Update swim phase but with decreasing speed
                this.swimPhase += this.swimSpeed;
                
                // Fish floats upward slightly
                this.position.y += 0.1 * deltaTime * 60;
                
                // Fish rolls over (rotates on z-axis)
                const rollAngle = progress * Math.PI * 0.5; // 90-degree roll
                
                // Calculate shrink factor (moved outside the if block so it's available for both mesh and glowMesh)
                const shrinkFactor = 1 - progress * 0.4;
                
                // Update mesh opacity and scale
                if (this.mesh) {
                    // Fade out
                    if (!this.mesh.material.transparent) {
                        this.mesh.material.transparent = true;
                    }
                    this.mesh.material.opacity = 1 - progress * 0.8; // Don't fade completely
                    
                    // Apply roll and slightly shrink
                    this.mesh.rotation.y = rollAngle; // Apply roll
                    this.mesh.scale.set(shrinkFactor, shrinkFactor, 1);
                }
                
                if (this.glowMesh) {
                    this.glowMesh.material.opacity = (1 - progress) * 0.2; // Fade glow faster
                    this.glowMesh.rotation.y = rollAngle; // Apply same roll
                    this.glowMesh.scale.set(shrinkFactor, shrinkFactor, 1);
                    
                    // Fade glow color to a darker shade
                    const baseColor = new THREE.Color(this.color);
                    const darkColor = new THREE.Color(0x000022);
                    const fadeColor = baseColor.clone().lerp(darkColor, progress);
                    
                    // Update glow color uniforms
                    if (this.glowMesh.material.uniforms) {
                        this.glowMesh.material.uniforms.energy.value = this.energy * (1 - progress);
                        this.glowMesh.material.uniforms.color.value = hexToRgb(fadeColor.getHex());
                    }
                }
                
                // Update spine for last wiggle movements
                this.updateSpine(deltaTime * 60);
                this.updateMeshFromSpine();
                
                // Update mesh position
                this.mesh.position.set(this.position.x, this.position.y, 0);
                this.glowMesh.position.set(this.position.x, this.position.y, 0);
                
                // End of animation - mark as fully dead
                if (progress >= 1.0) {
                    this.isDead = true;
                }
            }
            
            startDying() {
                this.isDying = true;
                this.deathTime = 0;
                
                // Create death particles - subtle bubbles rising
                createDeathBubbles(this.position.x, this.position.y, this.color);
            }
        }
        
        // Create fish array
        const fishes = [];
        
        // Initialize flow field and current indicators
        initializeFlowField();
        initializeWaterVisualization();
        
        // Create initial fish - add more to match original density
        for (let i = 0; i < 20; i++) {
            const fish = new Fish();
            // Spread fish throughout the visible area
            fish.position.set(
                (Math.random() - 0.5) * viewSize * aspectRatio,
                (Math.random() - 0.5) * viewSize,
                0
            );
            fishes.push(fish);
        }
        
        // Add one fish explicitly in the top-left corner
        const topLeftFish = new Fish();
        const bounds = viewSize * aspectRatio / 2;
        topLeftFish.position.set(-bounds * 0.8, viewSize/2 * 0.8, 0);
        // Make it face slightly inward
        topLeftFish.angle = Math.PI / 4; // 45 degrees
        fishes.push(topLeftFish);
        
        // CRITICAL FIX: Add velocity reset function to handle tab switching
        function resetAllFishVelocities() {
            for (const fish of fishes) {
                // Reset to reasonable values to prevent extreme speeds after tab switch
                fish.velocity.x = Math.cos(fish.angle) * fish.targetVelocity * 0.1;
                fish.velocity.y = Math.sin(fish.angle) * fish.targetVelocity * 0.1;
            }
        }
        
        // Mouse movement tracking
        document.addEventListener('mousemove', (e) => {
            pmouseX = mouseX;
            pmouseY = mouseY;
            
            // Convert to world coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            
            mouseX = x * (viewSize * aspectRatio / 2);
            mouseY = y * (viewSize / 2);
            mouseInfluence = true;
            
            // Reset mouse influence after some time
            clearTimeout(window.mouseTimer);
            window.mouseTimer = setTimeout(() => {
                mouseInfluence = false;
            }, 5000);
        });
        
        // Animation loop
        const clock = new THREE.Clock();
        let frameCount = 0;
        let fpsTime = 0;
        const fpsElement = document.getElementById('fps');
        let lastTime = performance.now();
        let inBackgroundMode = false;
        
        // TWEAK AREA 12: Global Bloom Pulsation
        // Variables to control the overall bloom effect's subtle breathing/pulsation
        let globalTime = 0;

        // Adjust these values to control the global "breathing" effect
        // Lower speeds = slower pulsation (values around 0.1-0.3 feel natural)
        // Higher amounts = more dramatic effect (keep under 0.1 for subtle effect)
        const bloomPulsationSpeed = 0.2;  // Cycles per second for strength (lower = slower)
        const bloomPulsationAmount = 0.05; // Strength variation (0-1, higher = more dramatic)
        const radiusPulsationSpeed = 0.15; // Different speed for radius pulsation
        const radiusPulsationAmount = 0.03; // Subtle radius variation
        const thresholdPulsationSpeed = 0.12; // Even slower for threshold
        const thresholdPulsationAmount = 0.02; // Very subtle threshold variation
        
        // Handle visibility changes - but don't pause animation
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                inBackgroundMode = true;
                // Reset the clock to avoid large deltaTime on return
                clock.getDelta(); // This resets the internal clock time
                lastTime = performance.now();
            } else {
                inBackgroundMode = false;
                // Reset the clock to avoid large deltaTime on return
                clock.getDelta(); // This resets the internal clock time
                lastTime = performance.now();
                
                // CRITICAL FIX: Reset fish velocities on tab return
                resetAllFishVelocities();
            }
        });
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Get and cap delta time to prevent physics explosions after tab focus
            let deltaTime = clock.getDelta();
            
            // Monitor framerate for spikes that could indicate desktop switching
            monitorFramerate(deltaTime);
            
            // Cap maximum delta time to prevent large time steps
            // This prevents physics from going crazy when returning from another desktop
            const MAX_DELTA = 0.1; // 100ms maximum time step
            if (deltaTime > MAX_DELTA) {
                console.log(`Delta time capped from ${deltaTime} to ${MAX_DELTA}`);
                deltaTime = MAX_DELTA;
            }
            
            // If in background, use a fixed small delta time to keep animation smooth but slow
            if (inBackgroundMode) {
                deltaTime = 0.016; // ~60fps equivalent
            }
            
            // Update global time for bloom pulsation
            globalTime += deltaTime;
            
            // Apply sinusoidal pulsation to bloom effect
            const baseStrength = 0.15; // Base bloom strength (from TWEAK AREA 1)
            const baseRadius = 0.3;    // Base radius (from TWEAK AREA 1)
            const baseThreshold = 0.6; // Base threshold (from TWEAK AREA 1)

            // Create three slightly different pulsation patterns with phase offsets for organic feel
            const strengthPulse = Math.sin(globalTime * Math.PI * 2 * bloomPulsationSpeed) * bloomPulsationAmount + 1.0;
            const radiusPulse = Math.sin(globalTime * Math.PI * 2 * radiusPulsationSpeed + 0.7) * radiusPulsationAmount + 1.0;
            const thresholdPulse = Math.sin(globalTime * Math.PI * 2 * thresholdPulsationSpeed + 1.5) * thresholdPulsationAmount + 1.0;

            // Apply to bloom parameters
            bloomPass.strength = baseStrength * strengthPulse;
            bloomPass.radius = baseRadius * radiusPulse;
            bloomPass.threshold = baseThreshold * thresholdPulse;
            
            // Safety check - if any NaN or invalid values occur, reset to defaults
            if (isNaN(bloomPass.strength) || isNaN(bloomPass.radius) || isNaN(bloomPass.threshold) ||
                bloomPass.strength <= 0 || bloomPass.radius <= 0 || bloomPass.threshold <= 0) {
                console.warn('Fixing invalid bloom parameters');
                bloomPass.strength = baseStrength;
                bloomPass.radius = baseRadius;
                bloomPass.threshold = baseThreshold;
            }
            
            // FPS calculation
            frameCount++;
            fpsTime += deltaTime;
            
            // Update FPS display every half second
            if (fpsTime >= 0.5) {
                const fps = Math.round(frameCount / fpsTime);
                fpsElement.textContent = `FPS: ${fps}`;
                // Reset counters
                frameCount = 0;
                fpsTime = 0;
            }
            
            // Update food system
            updateFood();
            
            // Update the overall water flow
            updateWaterFlow();
            
            // Update water visualization components with new system
            updateWaterVisualization(deltaTime);
            
            // Update all fish
            for (const fish of fishes) {
                fish.update(deltaTime);
            }
            
            // Remove dead fish
            for (let i = fishes.length - 1; i >= 0; i--) {
                if (fishes[i].isDead && fishes[i].deathTime >= fishes[i].deathDuration) {
                    // Remove the mesh from scene
                    if (fishes[i].mesh) {
                        scene.remove(fishes[i].mesh);
                        fishes[i].mesh.geometry.dispose();
                        fishes[i].mesh.material.dispose();
                    }
                    
                    if (fishes[i].glowMesh) {
                        scene.remove(fishes[i].glowMesh);
                        fishes[i].glowMesh.geometry.dispose();
                        fishes[i].glowMesh.material.dispose();
                    }
                    
                    // Remove from array
                    fishes.splice(i, 1);
                }
            }
            
            // Update death bubbles
            if (window.deathBubbles && window.deathBubbles.length > 0) {
                for (let i = window.deathBubbles.length - 1; i >= 0; i--) {
                    const bubble = window.deathBubbles[i];
                    bubble.userData.lifetime++;
                    
                    // Update position based on velocity
                    bubble.position.x += bubble.userData.velocityX;
                    bubble.position.y += bubble.userData.velocityY;
                    
                    // Get local flow and apply some influence
                    const flow = getFlowAtPosition(bubble.position.x, bubble.position.y);
                    bubble.position.x += flow.vx * 0.3;
                    bubble.position.y += flow.vy * 0.3;
                    
                    // Scale bubble (slowly shrink)
                    const scale = Math.max(0.1, 1 + bubble.userData.velocityScale * bubble.userData.lifetime);
                    bubble.scale.set(scale, scale, 1);
                    
                    // Calculate fade based on lifetime
                    const progress = bubble.userData.lifetime / bubble.userData.maxLifetime;
                    bubble.material.opacity = (1 - progress) * 0.5;
                    
                    // Remove when animation completed
                    if (bubble.userData.lifetime >= bubble.userData.maxLifetime) {
                        scene.remove(bubble);
                        bubble.geometry.dispose();
                        bubble.material.dispose();
                        window.deathBubbles.splice(i, 1);
                    }
                }
            }
            
            // Update visual effect rings
            if (window.effectRings && window.effectRings.length > 0) {
                for (let i = window.effectRings.length - 1; i >= 0; i--) {
                    const ring = window.effectRings[i];
                    ring.userData.lifetime++;
                    
                    // Calculate scale and opacity based on lifetime
                    const progress = ring.userData.lifetime / ring.userData.maxLifetime;
                    const scale = 1 + progress * ring.userData.maxScale;
                    const opacity = 1 - progress;
                    
                    // Apply animation
                    ring.scale.set(scale, scale, 1);
                    ring.material.opacity = opacity;
                    
                    // Remove if completed
                    if (ring.userData.lifetime >= ring.userData.maxLifetime) {
                        scene.remove(ring);
                        ring.geometry.dispose();
                        ring.material.dispose();
                        window.effectRings.splice(i, 1);
                    }
                }
            }
            
            // Update food consumption effects
            if (window.foodEffects && window.foodEffects.length > 0) {
                for (let i = window.foodEffects.length - 1; i >= 0; i--) {
                    const effect = window.foodEffects[i];
                    effect.userData.lifetime++;
                    
                    // Calculate progress 
                    const progress = effect.userData.lifetime / effect.userData.maxLifetime;
                    // Use ease-in for acceleration toward fish
                    const eased = progress * progress; // Quadratic ease-in
                    
                    // Update position - move toward fish
                    const x = effect.userData.startX + (effect.userData.targetX - effect.userData.startX) * eased;
                    const y = effect.userData.startY + (effect.userData.targetY - effect.userData.startY) * eased;
                    effect.position.set(x, y, 0);
                    
                    // Update scale - shrink as it gets eaten
                    const scale = effect.userData.startScale + 
                                 (effect.userData.endScale - effect.userData.startScale) * eased;
                    effect.scale.set(scale, scale, 1);
                    
                    // Update opacity - fade out as it gets eaten
                    effect.material.opacity = 1 - eased;
                    
                    // Remove when animation completed
                    if (effect.userData.lifetime >= effect.userData.maxLifetime) {
                        scene.remove(effect);
                        effect.geometry.dispose();
                        effect.material.dispose();
                        window.foodEffects.splice(i, 1);
                    }
                }
            }
            
            // Update splash particles from eating
            if (window.splashParticles && window.splashParticles.length > 0) {
                for (let i = window.splashParticles.length - 1; i >= 0; i--) {
                    const particle = window.splashParticles[i];
                    particle.userData.lifetime++;
                    
                    // Update position based on velocity
                    particle.position.x += particle.userData.velocityX;
                    particle.position.y += particle.userData.velocityY;
                    
                    // Apply gravity and drag
                    particle.userData.velocityY -= 0.03; // Gravity
                    particle.userData.velocityX *= 0.95; // Drag
                    
                    // Calculate fade based on lifetime
                    const progress = particle.userData.lifetime / particle.userData.maxLifetime;
                    particle.material.opacity = 0.8 * (1 - progress);
                    
                    // Remove when animation completed
                    if (particle.userData.lifetime >= particle.userData.maxLifetime) {
                        scene.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                        window.splashParticles.splice(i, 1);
                    }
                }
            }
            
            // Render with post-processing
            composer.render();
        }
        
        // Special handler for when browser window loses/gains focus
        // Different from visibility change - handles virtual desktop switches better
        window.addEventListener('blur', () => {
            inBackgroundMode = true;
            // Reset the clock to avoid large deltaTime on return
            clock.getDelta();
            lastTime = performance.now();
        });
        
        window.addEventListener('focus', () => {
            inBackgroundMode = false;
            // Reset simulation timing to prevent large delta time
            clock.getDelta(); // Reset internal clock
            lastTime = performance.now();
            
            // CRITICAL FIX: Reset fish velocities to prevent any extreme speeds
            resetAllFishVelocities();
        });
        
        // Monitor framerate and reset simulation if it gets choppy
        let lastFewDeltas = []; // Store last several deltas
        const MAX_SAVED_DELTAS = 5;
        
        function monitorFramerate(deltaTime) {
            lastFewDeltas.push(deltaTime);
            if (lastFewDeltas.length > MAX_SAVED_DELTAS) {
                lastFewDeltas.shift();
            }
            
            // If we have enough samples and see a huge jump, reset things
            if (lastFewDeltas.length === MAX_SAVED_DELTAS) {
                const avgDelta = lastFewDeltas.reduce((sum, val) => sum + val, 0) / MAX_SAVED_DELTAS;
                const latestDelta = lastFewDeltas[lastFewDeltas.length - 1];
                
                // If sudden spike in frame time, reset the simulation
                if (latestDelta > avgDelta * 5) {
                    console.log("Detected framerate spike, resetting simulation timing");
                    clock.getDelta(); // Reset the clock
                    
                    // CRITICAL FIX: Reset fish velocities when framerate tanks
                    resetAllFishVelocities();
                }
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const newAspectRatio = window.innerWidth / window.innerHeight;
            
            // Update camera
            camera.left = -viewSize * newAspectRatio / 2;
            camera.right = viewSize * newAspectRatio / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            
            // Update renderer and passes
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            
            // Update SMAA pass
            smaaPass.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Track double-click for adding fish
        let lastClickTime = 0;
        let lastClickX = 0;
        let lastClickY = 0;
        const doubleClickThreshold = 300; // ms

        // Helper function to create fish at specified position
        function createFishAt(worldX, worldY) {
            // Create a new fish here
            const fish = new Fish();
            fish.position.set(worldX, worldY, 0);
            
            // Initialize spine points
            fish.initializeSpine();
            
            // Add to collection
            fishes.push(fish);
            
            // Create visual feedback - a temporary expanding ring
            createFishAddedEffect(worldX, worldY, fish.color);
            
            // Add smooth appearing animation to the fish
            // Start very small and transparent
            fish.mesh.scale.set(0.01, 0.01, 1);
            fish.glowMesh.scale.set(0.01, 0.01, 1);
            fish.mesh.material.transparent = true;
            fish.mesh.material.opacity = 0;
            
            // Animation data for growing effect
            fish.appearanceAnimation = {
                active: true,
                duration: 45, // frames
                progress: 0,
                targetScale: 1,
                startOpacity: 0,
                targetOpacity: 1
            };
        }

        // Create visual feedback for fish addition
        function createFishAddedEffect(x, y, color) {
            // Create a ring geometry
            const ringGeometry = new THREE.RingGeometry(0.5, 1.5, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.7, 
                side: THREE.DoubleSide 
            });
            
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.set(x, y, 0);
            scene.add(ring);
            
            // Animation data
            ring.userData = {
                lifetime: 0,
                maxLifetime: 60, // frames
                maxScale: 8
            };
            
            // Add to a collection for animation
            if (!window.effectRings) window.effectRings = [];
            window.effectRings.push(ring);
        }

        // Mouse event handling - left click for food, right click for fish
        renderer.domElement.addEventListener('mousedown', (e) => {
            // Get click position using raycasting for more accurate positioning
            const rect = renderer.domElement.getBoundingClientRect();
            
            // Normalize mouse coordinates to [-1, 1]
            const normalizedX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            const normalizedY = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Create a raycaster
            const raycaster = new THREE.Raycaster();
            const mouseVector = new THREE.Vector2(normalizedX, normalizedY);
            
            // Set the raycasting approach for orthographic camera
            raycaster.setFromCamera(mouseVector, camera);
            
            // Create a plane at z=0 to intersect with
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));
            const intersectPoint = new THREE.Vector3();
            
            // Calculate the intersection point
            raycaster.ray.intersectPlane(plane, intersectPoint);
            
            const worldX = intersectPoint.x;
            const worldY = intersectPoint.y;
            
            if (e.button === 0) {
                // Left click - add food
                addFood(worldX, worldY);
            } else if (e.button === 2) {
                // Right click - add fish
                createFishAt(worldX, worldY);
                e.preventDefault(); // Prevent context menu
            }
        });

        // Prevent context menu from appearing on right-click
        renderer.domElement.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Touch double-tap handling for mobile devices
        let lastTapTime = 0;
        let lastTapX = 0;
        let lastTapY = 0;
        const doubleTapThreshold = 300; // ms

        renderer.domElement.addEventListener('touchstart', (e) => {
            if (e.touches.length !== 1) return; // Only handle single touches
            
            const currentTime = performance.now();
            const timeDiff = currentTime - lastTapTime;
            
            // Get touch position using raycasting
            const rect = renderer.domElement.getBoundingClientRect();
            const touch = e.touches[0];
            
            // Normalize touch coordinates to [-1, 1]
            const normalizedX = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
            const normalizedY = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Create a raycaster
            const raycaster = new THREE.Raycaster();
            const touchVector = new THREE.Vector2(normalizedX, normalizedY);
            
            // Set the raycasting approach for orthographic camera
            raycaster.setFromCamera(touchVector, camera);
            
            // Create a plane at z=0 to intersect with
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));
            const intersectPoint = new THREE.Vector3();
            
            // Calculate the intersection point
            raycaster.ray.intersectPlane(plane, intersectPoint);
            
            const worldX = intersectPoint.x;
            const worldY = intersectPoint.y;
            
            // Check if this is a double-tap
            if (timeDiff < doubleTapThreshold) {
                // Create fish at tap position
                createFishAt(worldX, worldY);
                
                // Prevent default behavior
                e.preventDefault();
            } else {
                // Single tap - add food (will be handled on touchend)
                lastTapTime = currentTime;
                lastTapX = worldX;
                lastTapY = worldY;
            }
        }, { passive: false });

        // Handle single tap for adding food
        renderer.domElement.addEventListener('touchend', (e) => {
            e.preventDefault();
            
            const currentTime = performance.now();
            const timeDiff = currentTime - lastTapTime;
            
            // If this wasn't part of a double tap, add food
            if (lastTapTime > 0 && timeDiff < doubleTapThreshold) {
                // Wait a bit to ensure this isn't the first tap of a double-tap
                setTimeout(() => {
                    // If lastTapTime hasn't been reset by a double-tap detection
                    if (lastTapTime > 0 && (performance.now() - lastTapTime) >= doubleTapThreshold) {
                        // It was a single tap - add food
                        addFood(lastTapX, lastTapY);
                        lastTapTime = 0;
                    }
                }, doubleTapThreshold);
            }
        });
        
        // Update mouse movement tracking to use the same raycasting approach
        document.addEventListener('mousemove', (e) => {
            pmouseX = mouseX;
            pmouseY = mouseY;
            
            // Get mouse position using raycasting
            const rect = renderer.domElement.getBoundingClientRect();
            
            // Normalize mouse coordinates to [-1, 1]
            const normalizedX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            const normalizedY = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Create a raycaster
            const raycaster = new THREE.Raycaster();
            const mouseVector = new THREE.Vector2(normalizedX, normalizedY);
            
            // Set the raycasting approach for orthographic camera
            raycaster.setFromCamera(mouseVector, camera);
            
            // Create a plane at z=0 to intersect with
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));
            const intersectPoint = new THREE.Vector3();
            
            // Calculate the intersection point
            raycaster.ray.intersectPlane(plane, intersectPoint);
            
            mouseX = intersectPoint.x;
            mouseY = intersectPoint.y;
            mouseInfluence = true;
            
            // Reset mouse influence after some time
            clearTimeout(window.mouseTimer);
            window.mouseTimer = setTimeout(() => {
                mouseInfluence = false;
            }, 5000);
        });

        // Create visual effect for food consumption
        function createFoodConsumptionEffect(food, fish) {
            // Create a copy of the food but as a custom effect
            const foodGeometry = new THREE.CircleGeometry(food.size, 8);
            const foodMaterial = new THREE.MeshBasicMaterial({ 
                color: food.color,
                transparent: true, 
                opacity: food.alpha 
            });
            
            const effect = new THREE.Mesh(foodGeometry, foodMaterial);
            effect.position.set(food.x, food.y, 0);
            scene.add(effect);
            
            // Calculate velocity toward fish mouth
            const fishHeadX = fish.position.x + Math.cos(fish.angle) * (fish.length * 0.3);
            const fishHeadY = fish.position.y + Math.sin(fish.angle) * (fish.length * 0.3);
            
            // Animation data
            effect.userData = {
                lifetime: 0,
                maxLifetime: 20, // frames
                startX: food.x,
                startY: food.y,
                targetX: fishHeadX,
                targetY: fishHeadY,
                startScale: 1.0,
                endScale: 0.1
            };
            
            // Add to a collection for animation
            if (!window.foodEffects) window.foodEffects = [];
            window.foodEffects.push(effect);
            
            // Create splash particles when food reaches the fish
            setTimeout(() => {
                createFoodSplashEffect(fishHeadX, fishHeadY, food.color, fish.angle);
            }, 333); // ~20 frames at 60fps
        }

        // Create splash particles when fish eats food
        function createFoodSplashEffect(x, y, color, fishAngle) {
            // Create several tiny particles
            const particleCount = 5 + Math.floor(Math.random() * 3);
            
            for (let i = 0; i < particleCount; i++) {
                // Create a small particle
                const particleGeometry = new THREE.CircleGeometry(0.2 + Math.random() * 0.3, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true, 
                    opacity: 0.8 
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Position at fish mouth
                particle.position.set(x, y, 0);
                scene.add(particle);
                
                // Random angle with bias toward fish's forward direction
                const angleSpread = Math.PI * 0.6; // 60 degree spread
                const angle = fishAngle + (Math.random() * angleSpread - angleSpread / 2);
                
                // Animation data
                particle.userData = {
                    lifetime: 0,
                    maxLifetime: 15 + Math.floor(Math.random() * 10),
                    velocityX: Math.cos(angle) * (0.5 + Math.random() * 0.5),
                    velocityY: Math.sin(angle) * (0.5 + Math.random() * 0.5)
                };
                
                // Add to a collection for animation
                if (!window.splashParticles) window.splashParticles = [];
                window.splashParticles.push(particle);
            }
        }

        // Create death bubbles effect when fish dies
        function createDeathBubbles(x, y, color) {
            // Number of bubbles based on fish position (more visible near center)
            const bounds = viewSize * aspectRatio / 2;
            const screenEdgeDistance = Math.min(
                Math.abs(x - (-bounds)),
                Math.abs(x - bounds),
                Math.abs(y - (-viewSize / 2)),
                Math.abs(y - viewSize / 2)
            );
            const isNearEdge = screenEdgeDistance < 50;
            
            // Fewer bubbles if near edge of screen
            const bubbleCount = isNearEdge ? 8 : 15;
            
            for (let i = 0; i < bubbleCount; i++) {
                // Create a small bubble
                const radius = 0.1 + Math.random() * 0.2;
                const geometry = new THREE.CircleGeometry(radius, 6);
                
                // Use a dimmer version of the fish color
                const bubbleColor = new THREE.Color(color).multiplyScalar(0.7);
                
                const material = new THREE.MeshBasicMaterial({
                    color: bubbleColor,
                    transparent: true,
                    opacity: 0.2 + Math.random() * 0.3,
                    blending: THREE.AdditiveBlending
                });
                
                const bubble = new THREE.Mesh(geometry, material);
                
                // Position with slight random offset from fish
                const offsetRange = 4;
                bubble.position.set(
                    x + (Math.random() - 0.5) * offsetRange,
                    y + (Math.random() - 0.5) * offsetRange,
                    1 // Slightly in front of fish
                );
                
                scene.add(bubble);
                
                // Animation data
                bubble.userData = {
                    lifetime: 0,
                    maxLifetime: 30 + Math.floor(Math.random() * 60),
                    velocityX: (Math.random() - 0.5) * 0.2,
                    velocityY: 0.1 + Math.random() * 0.2, // Mainly upward
                    velocityScale: -0.001 - Math.random() * 0.003 // Shrink rate
                };
                
                // Add to a collection for animation
                if (!window.deathBubbles) window.deathBubbles = [];
                window.deathBubbles.push(bubble);
            }
        }

        // Start animation
        animate();
    </script>
    
    <script>
        // Handle info panel toggle
        document.addEventListener('DOMContentLoaded', function() {
            const infoPanel = document.getElementById('info-panel');
            const minimizeBtn = document.getElementById('minimize-btn');
            const showInfoBtn = document.getElementById('show-info');
            
            minimizeBtn.addEventListener('click', function() {
                infoPanel.style.display = 'none';
                showInfoBtn.style.display = 'block';
            });
            
            showInfoBtn.addEventListener('click', function() {
                infoPanel.style.display = 'block';
                showInfoBtn.style.display = 'none';
            });
            
            // Auto-hide info panel after 10 seconds on desktop
            if (window.innerWidth > 768) {
                setTimeout(function() {
                    infoPanel.style.opacity = '0.5';
                }, 10000);
                
                infoPanel.addEventListener('mouseenter', function() {
                    infoPanel.style.opacity = '1';
                });
                
                infoPanel.addEventListener('mouseleave', function() {
                    infoPanel.style.opacity = '0.5';
                });
            }
            
            // Set appropriate controls based on device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 800;
            if (isMobile) {
                document.getElementById('desktop-controls').style.display = 'none';
                document.getElementById('mobile-controls').style.display = 'block';
            }
        });
    </script>
    
    <script>
        window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
    </script>
    <script defer src="/_vercel/insights/script.js"></script>
</body>
</html>